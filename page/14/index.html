<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="plantegg" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="java mysql tcp performance network docker Linux">
<meta property="og:type" content="website">
<meta property="og:title" content="plantegg">
<meta property="og:url" content="https://plantegg.github.io/page/14/index.html">
<meta property="og:site_name" content="plantegg">
<meta property="og:description" content="java mysql tcp performance network docker Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="plantegg">
<meta name="twitter:description" content="java mysql tcp performance network docker Linux">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://plantegg.github.io/page/14/"/>





  <title>plantegg - java tcp mysql performance network docker Linux</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">plantegg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">java tcp mysql performance network docker Linux</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-categories"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2017/03/24/docker daemon添加label/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weibo @plantegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/24/docker daemon添加label/" itemprop="url">如何手动为docker daemon添加label</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-24T17:30:03+08:00">
                2017-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何手动为docker-daemon添加label"><a href="#如何手动为docker-daemon添加label" class="headerlink" title="如何手动为docker daemon添加label"></a>如何手动为docker daemon添加label</h1><ol>
<li><p>编辑或创建/etc/docker/daemon.json</p>
</li>
<li><p>将一个或多个lable以json格式写入文件，示例如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 为docker分配两个label，分别是nodetype和red</div><div class="line">&#123;"labels":["nodetype=dbpaas", "color=red"]&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>重启docker daemon</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service docker restart</div></pre></td></tr></table></figure>
</li>
</ol>
<p>4 /etc/docker/daemon.json 参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;api-cors-header&quot;: &quot;&quot;,</div><div class="line">    &quot;authorization-plugins&quot;: [],</div><div class="line">    &quot;bip&quot;: &quot;&quot;,</div><div class="line">    &quot;bridge&quot;: &quot;&quot;,</div><div class="line">    &quot;cgroup-parent&quot;: &quot;&quot;,</div><div class="line">    &quot;cluster-store&quot;: &quot;&quot;,</div><div class="line">    &quot;cluster-store-opts&quot;: &#123;&#125;,</div><div class="line">    &quot;cluster-advertise&quot;: &quot;&quot;,</div><div class="line">    &quot;debug&quot;: true,</div><div class="line">    &quot;default-gateway&quot;: &quot;&quot;,</div><div class="line">    &quot;default-gateway-v6&quot;: &quot;&quot;,</div><div class="line">    &quot;default-runtime&quot;: &quot;runc&quot;,</div><div class="line">    &quot;default-ulimits&quot;: &#123;&#125;,</div><div class="line">    &quot;disable-legacy-registry&quot;: false,</div><div class="line">    &quot;dns&quot;: [],</div><div class="line">    &quot;dns-opts&quot;: [],</div><div class="line">    &quot;dns-search&quot;: [],</div><div class="line">    &quot;exec-opts&quot;: [],</div><div class="line">    &quot;exec-root&quot;: &quot;&quot;,</div><div class="line">    &quot;fixed-cidr&quot;: &quot;&quot;,</div><div class="line">    &quot;fixed-cidr-v6&quot;: &quot;&quot;,</div><div class="line">    &quot;graph&quot;: &quot;&quot;,</div><div class="line">    &quot;group&quot;: &quot;&quot;,</div><div class="line">    &quot;hosts&quot;: [],</div><div class="line">    &quot;icc&quot;: false,</div><div class="line">    &quot;insecure-registries&quot;: [],</div><div class="line">    &quot;ip&quot;: &quot;0.0.0.0&quot;,</div><div class="line">    &quot;iptables&quot;: false,</div><div class="line">    &quot;ipv6&quot;: false,</div><div class="line">    &quot;ip-forward&quot;: false,</div><div class="line">    &quot;ip-masq&quot;: false,</div><div class="line">    &quot;labels&quot;: [&quot;nodetype=drds-server&quot;, &quot;ark.ip=11.239.155.83&quot;],</div><div class="line">    &quot;live-restore&quot;: true,</div><div class="line">    &quot;log-driver&quot;: &quot;&quot;,</div><div class="line">    &quot;log-level&quot;: &quot;&quot;,</div><div class="line">    &quot;log-opts&quot;: &#123;&#125;,</div><div class="line">    &quot;max-concurrent-downloads&quot;: 3,</div><div class="line">    &quot;max-concurrent-uploads&quot;: 5,</div><div class="line">    &quot;mtu&quot;: 0,</div><div class="line">    &quot;oom-score-adjust&quot;: -500,</div><div class="line">    &quot;pidfile&quot;: &quot;&quot;,</div><div class="line">    &quot;raw-logs&quot;: false,</div><div class="line">    &quot;registry-mirrors&quot;: [],</div><div class="line">    &quot;runtimes&quot;: &#123;</div><div class="line">        &quot;runc&quot;: &#123;</div><div class="line">            &quot;path&quot;: &quot;runc&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;custom&quot;: &#123;</div><div class="line">            &quot;path&quot;: &quot;/usr/local/bin/my-runc-replacement&quot;,</div><div class="line">            &quot;runtimeArgs&quot;: [</div><div class="line">                &quot;--debug&quot;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;selinux-enabled&quot;: false,</div><div class="line">    &quot;storage-driver&quot;: &quot;&quot;,</div><div class="line">    &quot;storage-opts&quot;: [],</div><div class="line">    &quot;swarm-default-advertise-addr&quot;: &quot;&quot;,</div><div class="line">    &quot;tls&quot;: true,</div><div class="line">    &quot;tlscacert&quot;: &quot;&quot;,</div><div class="line">    &quot;tlscert&quot;: &quot;&quot;,</div><div class="line">    &quot;tlskey&quot;: &quot;&quot;,</div><div class="line">    &quot;tlsverify&quot;: true,</div><div class="line">    &quot;userland-proxy&quot;: false,</div><div class="line">    &quot;userns-remap&quot;: &quot;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Daemon.json 指定 ulimit等参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">cat &gt;&gt; /etc/docker/daemon.json &lt;&lt;EOF</div><div class="line">&#123;</div><div class="line">  &quot;data-root&quot;: &quot;/var/lib/docker&quot;,</div><div class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</div><div class="line">  &quot;log-opts&quot;: &#123;</div><div class="line">    &quot;max-size&quot;: &quot;200m&quot;,</div><div class="line">    &quot;max-file&quot;: &quot;5&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;default-ulimits&quot;: &#123;</div><div class="line">    &quot;nofile&quot;: &#123;</div><div class="line">      &quot;Name&quot;: &quot;nofile&quot;,</div><div class="line">      &quot;Hard&quot;: 655360,</div><div class="line">      &quot;Soft&quot;: 655360</div><div class="line">    &#125;,</div><div class="line">    &quot;nproc&quot;: &#123;</div><div class="line">      &quot;Name&quot;: &quot;nproc&quot;,</div><div class="line">      &quot;Hard&quot;: 655360,</div><div class="line">      &quot;Soft&quot;: 655360</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;live-restore&quot;: true,</div><div class="line">  &quot;oom-score-adjust&quot;: -1000,</div><div class="line">  &quot;max-concurrent-downloads&quot;: 10,</div><div class="line">  &quot;max-concurrent-uploads&quot;: 10,</div><div class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;,</div><div class="line">  &quot;storage-opts&quot;: [&quot;overlay2.override_kernel_check=true&quot;],</div><div class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</div><div class="line">  &quot;registry-mirrors&quot;: [</div><div class="line">    &quot;https://yssx4sxy.mirror.aliyuncs.com/&quot;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2017/03/24/docker swarm的Label使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weibo @plantegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/24/docker swarm的Label使用/" itemprop="url">docker、swarm的Label使用</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-24T17:30:03+08:00">
                2017-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="docker、swarm的Label使用"><a href="#docker、swarm的Label使用" class="headerlink" title="docker、swarm的Label使用"></a>docker、swarm的Label使用</h1><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>广发银行需要把方舟集群部署在多个机房（多个机房组成一个大集群），这样物理机和容器vlan没法互相完全覆盖，</p>
<p>也就是可能会出现A机房的网络subnet:192.168.1.0/24, B 机房的网络subnet：192.168.100.0/24 但是他们属于同一个vlan，要求如果容器在A机房的物理机拉起，分到的是192.168.1.0/24中的IP，B机房的容器分到的IP是：192.168.100.0/24</p>
<p><strong>功能实现：</strong></p>
<ul>
<li><strong>本质就是对所有物理机打标签，同一个asw下的物理机用同样的标签，不同asw下的物理机标签不同；</strong></li>
<li><strong>创建容器网络的时候也加标签，不同asw下的网络标签不一样，同时跟这个asw下的物理机标签匹配；</strong></li>
<li><strong>创建容器的时候使用 –net=driver:vlan 来动态选择多个vlan网络中的任意一个，然后swarm根据网络的标签要和物理机的标签一致，从而把容器调度到正确的asw下的物理机上。</strong></li>
</ul>
<p><strong>分为如下三个改造点</strong></p>
<p><strong>1：</strong></p>
<p>daemon启动的时候增加标签（其中一个就行）：</p>
<table>
<thead>
<tr>
<th>上联交换机组的名称，多个逗号隔开</th>
<th>com.alipay.acs.engine.asw.hostname</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><strong>2：</strong><br>创建网络的时候使用对应的标签：</p>
<table>
<thead>
<tr>
<th>网络域交换机组asw列表的名称，多个逗号隔开</th>
<th>com.alipay.acs.network.asw.hostname</th>
</tr>
</thead>
<tbody>
<tr>
<td>该VLAN网络是否必须显式指定，默认为0即不必须，此时当传入–net driver:vlan时ACS会根据调度结果自行选择一个可用的VLAN网络并拼装到参数中</td>
<td>com.alipay.acs.network.explicit</td>
</tr>
</tbody>
</table>
<p><strong>3：</strong></p>
<p>Swarm manager增加可选启动选项netarch.multiscope，值为true</p>
<h3 id="功能实现逻辑"><a href="#功能实现逻辑" class="headerlink" title="功能实现逻辑"></a>功能实现逻辑</h3><ol>
<li>Swarm manager增加可选启动选项netarch.multiscope，当为1时，network create时强制要求必须指定label描述配置VLAN的ASW信息</li>
<li>Swarm manager在创建容器时检查网络类型，VLAN网络时则将网络ASW的label放入过滤器中，在调度时按照机器的ASW标签过滤</li>
<li>如果使用者如果不关心具体使用哪个VLAN，则可以指定–net=”driver:vlan”，会自动查找driver=vlan的network，并根据调度结果（Node所关联的ASW）自动选择合适的network填入Config.HostConfig.NetworkMode传递给Docker daemon.</li>
</ol>
<p>如果是现存的环境，修改zk来更新网络标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 21] get /Cluster/docker/network/v1.0/network/c79e533e4444294ac9cb7838608115c961c6e403d3610367ff4b197ef6b981fc </div><div class="line">&#123;&quot;addrSpace&quot;:&quot;GlobalDefault&quot;,&quot;enableIPv6&quot;:false,&quot;generic&quot;:&#123;&quot;com.docker.network.enable_ipv6&quot;:false,&quot;com.docker.network.generic&quot;:&#123;&quot;VlanId&quot;:&quot;192&quot;&#125;&#125;,&quot;id&quot;:&quot;c79e533e4444294ac9cb7838608115c961c6e403d3610367ff4b197ef6b981fc&quot;,&quot;inDelete&quot;:false,&quot;internal&quot;:false,&quot;ipamOptions&quot;:&#123;&quot;VlanId&quot;:&quot;192&quot;&#125;,&quot;ipamType&quot;:&quot;default&quot;,&quot;ipamV4Config&quot;:&quot;[&#123;\&quot;PreferredPool\&quot;:\&quot;192.168.8.0/24\&quot;,\&quot;SubPool\&quot;:\&quot;\&quot;,\&quot;Gateway\&quot;:\&quot;192.168.8.1\&quot;,\&quot;AuxAddresses\&quot;:null&#125;]&quot;,&quot;ipamV4Info&quot;:&quot;[&#123;\&quot;IPAMData\&quot;:\&quot;&#123;\\\&quot;AddressSpace\\\&quot;:\\\&quot;\\\&quot;,\\\&quot;Gateway\\\&quot;:\\\&quot;192.168.8.1/24\\\&quot;,\\\&quot;Pool\\\&quot;:\\\&quot;192.168.8.0/24\\\&quot;&#125;\&quot;,\&quot;PoolID\&quot;:\&quot;GlobalDefault/192.168.8.0/24\&quot;&#125;]&quot;,&quot;labels&quot;:&#123;&#125;,&quot;name&quot;:&quot;vlan192-8&quot;,&quot;networkType&quot;:&quot;vlan&quot;,&quot;persist&quot;:true,&quot;postIPv6&quot;:false,&quot;scope&quot;:&quot;global&quot;&#125;</div><div class="line">cZxid = 0x4100008cce</div><div class="line">ctime = Fri Mar 09 12:46:44 CST 2018</div><div class="line">mZxid = 0x4100008cce</div><div class="line">mtime = Fri Mar 09 12:46:44 CST 2018</div><div class="line">pZxid = 0x4100008cce</div><div class="line">cversion = 0</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 716</div><div class="line">numChildren = 0</div></pre></td></tr></table></figure>
<p>//注意上面的网络还没有标签，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 28] set /Cluster/docker/network/v1.0/network/c79e533e4444294ac9cb7838608115c961c6e403d3610367ff4b197ef6b981fc &#123;&quot;addrSpace&quot;:&quot;GlobalDefault&quot;,&quot;enableIPv6&quot;:false,&quot;generic&quot;:&#123;&quot;com.docker.network.enable_ipv6&quot;:false,&quot;com.docker.network.generic&quot;:&#123;&quot;VlanId&quot;:&quot;192&quot;&#125;&#125;,&quot;id&quot;:&quot;c79e533e4444294ac9cb7838608115c961c6e403d3610367ff4b197ef6b981fc&quot;,&quot;inDelete&quot;:false,&quot;internal&quot;:false,&quot;ipamOptions&quot;:&#123;&quot;VlanId&quot;:&quot;192&quot;&#125;,&quot;ipamType&quot;:&quot;default&quot;,&quot;ipamV4Config&quot;:&quot;[&#123;\&quot;PreferredPool\&quot;:\&quot;192.168.8.0/24\&quot;,\&quot;SubPool\&quot;:\&quot;\&quot;,\&quot;Gateway\&quot;:\&quot;192.168.8.1\&quot;,\&quot;AuxAddresses\&quot;:null&#125;]&quot;,&quot;ipamV4Info&quot;:&quot;[&#123;\&quot;IPAMData\&quot;:\&quot;&#123;\\\&quot;AddressSpace\\\&quot;:\\\&quot;\\\&quot;,\\\&quot;Gateway\\\&quot;:\\\&quot;192.168.8.1/24\\\&quot;,\\\&quot;Pool\\\&quot;:\\\&quot;192.168.8.0/24\\\&quot;&#125;\&quot;,\&quot;PoolID\&quot;:\&quot;GlobalDefault/192.168.8.0/24\&quot;&#125;]&quot;,**&quot;labels&quot;:&#123;&quot;com.alipay.acs.network.asw.hostname&quot;:&quot;238&quot;&#125;,**&quot;name&quot;:&quot;vlan192-8&quot;,&quot;networkType&quot;:&quot;vlan&quot;,&quot;persist&quot;:true,&quot;postIPv6&quot;:false,&quot;scope&quot;:&quot;global&quot;&#125;</div></pre></td></tr></table></figure>
<p>example：</p>
<p>创建网络：//–label=”com.alipay.acs.network.asw.hostname=vlan902-63”<br>docker network create -d vlan –label=”com.alipay.acs.network.asw.hostname=vlan902-63” –subnet=11.162.63.0/24  –gateway=11.162.63.247  –opt VlanId=902 –ipam-opt VlanId=902 hanetwork2<br>跟daemon中的标签：com.alipay.acs.engine.asw.hostname=vlan902-63 对应，匹配调度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$sudo cat /etc/docker/daemon.json</div><div class="line">&#123;&quot;labels&quot;:[&quot;com.alipay.acs.engine.hostname=11.239.142.46&quot;,&quot;com.alipay.acs.engine.ip=11.239.142.46&quot;,&quot;com.alipay.acs.engine.device_type=Server&quot;,&quot;com.alipay.acs.engine.status=free&quot;,&quot;ark.network.vlan.range=vlan902-63&quot;,&quot;com.alipay.acs.engine.asw.hostname=vlan902-63&quot;,&quot;com.alipay.acs.network.asw.hostname=vlan902-63&quot;]&#125;</div><div class="line">//不指定具体网络，有多个网络的时候自动调度  --net driver:vlan 必须是network打过标签了</div><div class="line">docker run -d -it --name=&quot;udp10&quot; --net driver:vlan --restart=always reg.docker.alibaba-inc.com/middleware.udp</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2017/03/24/方舟环境容器调度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weibo @plantegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/24/方舟环境容器调度/" itemprop="url">方舟环境容器调度</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-24T17:30:03+08:00">
                2017-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="方舟环境容器调度"><a href="#方舟环境容器调度" class="headerlink" title="方舟环境容器调度"></a>方舟环境容器调度</h1><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul>
<li>恢复宿主机死机或者断网后上面需要调度的所有容器</li>
<li>恢复非正常的容器状态到正常</li>
<li>调度的容器能够支持vlan网络和Host模式</li>
<li>调度容器本身通过Leader-Follower的模式保证高可用性</li>
<li>调度容器支持cron定时任务（精确到秒级）</li>
<li>查询哪个节点是Leader</li>
<li>停止或者打开调度（方便容器维护、正常启停）</li>
</ul>
<h2 id="通过-ark-schedule-镜像启动调度"><a href="#通过-ark-schedule-镜像启动调度" class="headerlink" title="通过 ark-schedule 镜像启动调度"></a>通过 ark-schedule 镜像启动调度</h2><p>必须在swarm manager节点上以 docker 容器的方式来启动，下面的 -e 参数对应后面的 export 参数和作用注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d --restart=always --name=ark-schedule -e ACS_CLUSTER_SECURITY_GROUP=false -e ACS_CLUSTER_SCHEME=tcp -e ACS_CLUSTER_ENDPOINT=11.239.155.112:3376 -e ACS_NETWORK_NAME=vlan701 -e ACS_CRONTAB=&quot;7 * * * * *&quot; -e ACS_PORT=3375 -e ACS_ADVERTISE=11.239.155.112:3375 -e ACS_NETWORK_STORE_CLUSTER=zk://11.239.155.112:2181,11.239.155.103:2181,11.239.155.97:2181/Cluster -e affinity:container==swarm-manager --net=host reg.docker.alibaba-inc.com/ark/ark-schedule:0.6-20180530-68e7bed /ark-schedule/ark-schedule --debug start</div></pre></td></tr></table></figure>
<p>如果需要调度容器本身高可以用，需要在不同的宿主机上启动多个 ark-schedule 容器， 同时可以给调度容器自己增加调度标签</p>
<h3 id="环境变量参数说明"><a href="#环境变量参数说明" class="headerlink" title="环境变量参数说明"></a>环境变量参数说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">export ACS_CLUSTER_ENDPOINT=10.125.14.238:3376; //跟自己在同一台宿主机的swarm-manager</div><div class="line">export ACS_NETWORK_NAME=vlan192;  //方舟网络名称 docker network ls 看到vlan开头的名字</div><div class="line">export ACS_NETWORK_STORE_CLUSTER=zk://10.125.26.108:2181,10.125.14.238:2181,10.125.1.45:2181/Cluster; //方舟zk集群，同部署的ark.properties中的</div><div class="line">export ACS_CRONTAB=&quot;*/7 * * * * *&quot; </div><div class="line">export ACS_PORT=&quot;3375&quot; //schedule 自身api暴露端口</div><div class="line">export ACS_ADVERTISE=&quot;10.125.14.238:3375&quot; //宿主机ip+自身api暴露端口 多个schedule容器唯一</div><div class="line">./ark-schedule --debug start</div></pre></td></tr></table></figure>
<p>ark-schedule 容器默认占用3375端口，如果要用别的端口需要通过 -e ACS_PORT 参数传入</p>
<p><code>-e ACS_CRONTAB=&quot;7 * * * * *&quot; （秒 分 时 天 月 星期）</code></p>
<p>这个参数如果没有，那么需要外部来触发调度API（见下面）</p>
<p>ACS_ADVERTISE=”10.125.26.108:3375”  这个参数是多容器选举用的，每个容器用自己的IP+PORT来标识</p>
<p>容器日志主要在 /root/logs/ark-schedule-container-2017-12-12.log 中， 可以映射到宿主机上，查看更方便</p>
<h3 id="镜像版本"><a href="#镜像版本" class="headerlink" title="镜像版本"></a>镜像版本</h3><p>0.1 带cron功能，自动定时扫描并恢复容器<br>0.2-election 有多个ark-schedule节点选举功能，抢到主的开始cron，没有抢到或者失去主的stop cron<br>0.3-election 在0.2的基础上修复了docker/libkv的bug，能够在弱网络、断网的条件下正常运行<br>0.4-switch 增加查询leader节点和cron是否开始的API，增加对Leader的cron启停的API<br>0.5-labels 增加对restart/recreate 标签的支持<br>0.6 去掉了对多个zk的支持，简化启动参数<br>0.7 修复了重复endpoint导致的容器的域名不通、inspect notfound（集群多个同名容器的时候）等各种问题</p>
<h2 id="所有需要调度的容器增加调度标志标签"><a href="#所有需要调度的容器增加调度标志标签" class="headerlink" title="所有需要调度的容器增加调度标志标签"></a>所有需要调度的容器增加调度标志标签</h2><p>在docker run中增加一个标签： –label “ark.labels.schedule=haproxy”</p>
<p>详细命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker update --label-add=&quot;ark.labels.schedule=haproxy&quot; --label-add=&quot;ark.enable_restart=true&quot; --label-add=&quot;ark.enable_recreate=true&quot; 容器名1 容器名2</div></pre></td></tr></table></figure>
<p><strong>上述命令不需要重启容器，但是要重新调snapshot API 做一次快照，让他们生效</strong></p>
<p>ark-schedule容器在调度容器的时候，先检查快照中的容器，如果容器不见了或者状态不是up，又包含如上标签，就会重新在其它机器上把这个容器拉起来</p>
<ul>
<li><p>ark.enable_restart<br>是否允许通过重启来恢复容器（默认是true）。true为可以，false不可以</p>
</li>
<li><p>ark.enable_recreate<br>是否允许将消失的容器在其他宿主机重建（默认是true）。true为可以，false不可以</p>
</li>
</ul>
<h2 id="API-（如下ip：10-125-14-238-在现场换成客户物理机IP）"><a href="#API-（如下ip：10-125-14-238-在现场换成客户物理机IP）" class="headerlink" title="API （如下ip：10.125.14.238 在现场换成客户物理机IP）"></a>API （如下ip：10.125.14.238 在现场换成客户物理机IP）</h2><ol>
<li>中间件部署完毕，并检查无误，调用： curl -v “<a href="http://10.125.14.238:3375/schedule/snapshot" target="_blank" rel="external">http://10.125.14.238:3375/schedule/snapshot</a>“ 对中间件做快照，将来会按快照的状态来进行恢复，执行一次就可以</li>
<li>手动恢复容器不见了，调用 curl -v “<a href="http://10.125.14.238:3375/schedule/snapshot/restore" target="_blank" rel="external">http://10.125.14.238:3375/schedule/snapshot/restore</a>“ 会将所有异常容器恢复回来</li>
<li>schedule 容器本身的健康检查接口 curl <a href="http://10.125.14.238:3375/schedule/leader" target="_blank" rel="external">http://10.125.14.238:3375/schedule/leader</a> http code 值是 200,说明schedule容器是健康的</li>
<li>查询哪个节点是Leader curl 以及是否是停止调度（维护时）： “<a href="http://10.125.14.238:3375/schedule/leader" target="_blank" rel="external">http://10.125.14.238:3375/schedule/leader</a>“</li>
<li>停止调度，先查询谁是leader，然后调： “<a href="http://leader-ip:3375/schedule/stop" target="_blank" rel="external">http://leader-ip:3375/schedule/stop</a>“</li>
</ol>
<h2 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h2><p>通过调度容器API停止调度，所有容器都不再被调度了，维护完毕再调snapshot、start API恢复调度。</p>
<p>如果只想对某个容器进行维护，其它容器还是希望被调度监控、调度可以通过下面的方式来实现：</p>
<p><code>docker update --label-rm=&quot;ark.labels.schedule=haproxy&quot; 容器1 容器2 //还可以跟多个容器名</code><br><strong>然后调 snapshot API让刚刚的update生效</strong></p>
<p>运维完毕，恢复运维后的容器进入可以调度状态，具体命令如下：</p>
<p><code>docker update --label-add=&quot;ark.labels.schedule=haproxy&quot; 容器1 容器2 //还可以跟多个容器名</code></p>
<p><strong>然后调 snapshot API让刚刚的update生效</strong></p>
<p><img src="/images/oss/b055cf8f275749491fc768fab1ffd1a5.png" alt="image.png"></p>
<h2 id="升级ark-schedule步骤："><a href="#升级ark-schedule步骤：" class="headerlink" title="升级ark-schedule步骤："></a>升级ark-schedule步骤：</h2><h3 id="下载并导入新镜像"><a href="#下载并导入新镜像" class="headerlink" title="下载并导入新镜像"></a>下载并导入新镜像</h3><p>下载镜像：<a href="http://fzpackages.oss-cn-shanghai.aliyuncs.com/ark%2Fpatch%2Fark-schedule-0.6-20180530-68e7bed.tgz" target="_blank" rel="external">http://fzpackages.oss-cn-shanghai.aliyuncs.com/ark%2Fpatch%2Fark-schedule-0.6-20180530-68e7bed.tgz</a><br>sudo docker load -i ark-schedule-0.6-20180530-68e7bed.tgz</p>
<h3 id="停止原来的ark-schedule"><a href="#停止原来的ark-schedule" class="headerlink" title="停止原来的ark-schedule"></a>停止原来的ark-schedule</h3><p>停止两个crontab(新的ark-schedule自带crontab，每分钟执行一次调度)</p>
<p>停止两个ark-schedule容器</p>
<h3 id="启动新的ark-schdule"><a href="#启动新的ark-schdule" class="headerlink" title="启动新的ark-schdule"></a>启动新的ark-schdule</h3><p>在停止的两个ark-schedule的两台机器上启动两个新的ark-schedule容器，启动参数需要修改参考前面的描述(用现场环境信息替换下面的信息)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">export ACS_CLUSTER_ENDPOINT=10.125.14.238:3376; //跟自己在同一台宿主机的swarm-manager</div><div class="line">export ACS_NETWORK_NAME=vlan192;  //方舟网络名称 docker network ls 看到vlan开头的名字</div><div class="line">export ACS_NETWORK_STORE_CLUSTER=zk://10.125.26.108:2181,10.125.14.238:2181,10.125.1.45:2181/Cluster; //方舟zk集群，同部署的ark.properties中的</div><div class="line">export ACS_CRONTAB=&quot;*/7 * * * * *&quot;  ----不需要改</div><div class="line">export ACS_PORT=&quot;3375&quot; //schedule 自身api暴露端口----不需要改</div><div class="line">export ACS_ADVERTISE=&quot;10.125.14.238:3375&quot; //宿主机ip+自身api暴露端口 多个schedule容器唯一</div><div class="line">./ark-schedule --debug start //----不需要改</div></pre></td></tr></table></figure>
<h2 id="检查调度日志"><a href="#检查调度日志" class="headerlink" title="检查调度日志"></a>检查调度日志</h2><p>检查两个ark-schedule 谁是主： curl <a href="http://ark-schedule所在的宿主机-ip:3375/schedule/leader" target="_blank" rel="external">http://ark-schedule所在的宿主机-ip:3375/schedule/leader</a> </p>
<p>进到是主的ark-schedule容器中看日志：cat /root/logs/ark-schedule-2018-日期.log</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>如何打标签 <a href="http://panama.alibaba-inc.com/qa/faq?id=1124" title="http://panama.alibaba-inc.com/qa/faq?id=1124" target="_blank" rel="external">http://panama.alibaba-inc.com/qa/faq?id=1124</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2017/03/24/物理机磁盘空间去哪了/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weibo @plantegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/24/物理机磁盘空间去哪了/" itemprop="url">物理机磁盘空间都去哪里了</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-24T17:30:03+08:00">
                2017-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="磁盘爆掉的几种情况"><a href="#磁盘爆掉的几种情况" class="headerlink" title="磁盘爆掉的几种情况"></a>磁盘爆掉的几种情况</h1><ol>
<li>系统磁盘没有空间，解决办法：删掉 /var/log/ 下边的带日期的日志，清空 /var/log/messages 内容</li>
<li>容器使用的大磁盘空间不够，又有三个地方会使用大量的磁盘<ul>
<li>容器内部日志非常大，处理办法见方法一</li>
<li>容器内部产生非常多或者非常大的文件，但是这个文件的位置又通过volume 挂载到了物理机上，处理办法见方法二</li>
<li>对特别老的部署环境，还有可能是容器的系统日志没有限制大小，处理办法见方法三</li>
</ul>
</li>
</ol>
<h2 id="现场的同学按如下方法依次检查"><a href="#现场的同学按如下方法依次检查" class="headerlink" title="现场的同学按如下方法依次检查"></a>现场的同学按如下方法依次检查</h2><h3 id="方法零：-检查系统根目录下每个文件夹的大小"><a href="#方法零：-检查系统根目录下每个文件夹的大小" class="headerlink" title="方法零： 检查系统根目录下每个文件夹的大小"></a>方法零： 检查系统根目录下每个文件夹的大小</h3><p><code>sudo du / -lh --max-depth=1 --exclude=overlay --exclude=proc</code></p>
<p>看看除了容器之外有没有其它目录使用磁盘特别大，如果有那么一层层进去通过du命令来查看，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#sudo du / -lh --max-depth=1 --exclude=overlay --exclude=proc</div><div class="line">16K	/dev</div><div class="line">16K	/lost+found</div><div class="line">4.0K	/media</div><div class="line">17G	/home</div><div class="line">136M	/boot</div><div class="line">832K	/run</div><div class="line">1.9G	/usr</div><div class="line">75M	/tmp</div><div class="line">12K	/log</div><div class="line">8.5G	/var</div><div class="line">4.0K	/srv</div><div class="line">0	/proc</div><div class="line">22M	/etc</div><div class="line">84G	/root</div><div class="line">4.0K	/mnt</div><div class="line">508M	/opt</div><div class="line">0	/sys</div><div class="line">112G	/</div></pre></td></tr></table></figure>
<p>那么这个案例中应该查看 /root下为什么用掉了84G（总共用了112G）， 先 cd /root 然后执行： sudo du . -lh –max-depth=1 –exclude=overlay 进一步查看 /root 目录下每个文件夹的大小</p>
<p><strong>如果方法零没找到占用特别大的磁盘文件，那么一般来说是容器日志占用太多的磁盘空间，请看方法一</strong></p>
<h3 id="方法一：-容器内部日志非常大（请确保先按方法零检查过了）"><a href="#方法一：-容器内部日志非常大（请确保先按方法零检查过了）" class="headerlink" title="方法一： 容器内部日志非常大（请确保先按方法零检查过了）"></a>方法一： 容器内部日志非常大（请确保先按方法零检查过了）</h3><p>在磁盘不够的物理机上执行如下脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sudo docker ps -a -q &gt;containers.list</div><div class="line"></div><div class="line">sudo cat containers.list | xargs sudo docker inspect $1 | grep merged | awk -F \&quot; &apos;&#123; print $4 &#125;&apos; | sed &apos;s/\/merged//g&apos; | xargs sudo du  --max-depth=0 $1 &gt;containers.size </div><div class="line"></div><div class="line">sudo paste containers.list containers.size | awk &apos;&#123; print $1, $2 &#125;&apos;  | sort -nk2 &gt;real_size.log</div><div class="line"></div><div class="line">sudo tail -10 real_size.log  | awk &apos;BEGIN &#123;print &quot;\tcontainer     size\tunit&quot;&#125; &#123; print NR&quot;:\t&quot; $0&quot;\t kB&quot; &#125;&apos;</div></pre></td></tr></table></figure>
<h5 id="执行完后会输出如下格式："><a href="#执行完后会输出如下格式：" class="headerlink" title="执行完后会输出如下格式："></a>执行完后会输出如下格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   	container     size	unit</div><div class="line">1:	22690f16822f 3769980	 kb</div><div class="line">2:	82b4ae98eeed 4869324	 kb</div><div class="line">3:	572a1b7c8ef6 10370404	 kb</div><div class="line">4:	9f9250d98df6 10566776	 kb</div><div class="line">5:	7fab70481929 13745648	 kb</div><div class="line">6:	4a14b58e3732 29873504	 kb</div><div class="line">7:	8a01418b6df2 30432068	 kb</div><div class="line">8:	83dc85caaa5c 31010960	 kb</div><div class="line">9:	433e51df88b1 35647052	 kb</div><div class="line">10:	4b42818a8148 61962416	 kb</div></pre></td></tr></table></figure>
<p>第二列是容器id，第三列是磁盘大小，第四列是单位， 占用最大的排在最后面</p>
<h5 id="然后进到容器后通过-du-–max-depth-2-快速发现大文件"><a href="#然后进到容器后通过-du-–max-depth-2-快速发现大文件" class="headerlink" title="然后进到容器后通过 du / –max-depth=2 快速发现大文件"></a>然后进到容器后通过 du / –max-depth=2 快速发现大文件</h5><h3 id="方法二：-容器使用的volume使用过大"><a href="#方法二：-容器使用的volume使用过大" class="headerlink" title="方法二： 容器使用的volume使用过大"></a>方法二： 容器使用的volume使用过大</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$sudo du -l /data/lib/docker/defaultVolumes --max-depth=1 | sort -rn</div><div class="line">456012884	/data/lib/docker/defaultVolumes</div><div class="line">42608332	/data/lib/docker/defaultVolumes/task_3477_g0_ark-metadb_miniDBPaaS-MetaDB_1</div><div class="line">32322220	/data/lib/docker/defaultVolumes/task_3477_g0_dbpaas-metadb_dbpaas_1</div><div class="line">27461120	/data/lib/docker/defaultVolumes/task_3001_g0_ark-metadb_miniDBPaaS-MetaDB_1</div><div class="line">27319360	/data/lib/docker/defaultVolumes/task_36000_g0_ark-metadb_miniDBPaaS-MetaDB</div><div class="line">27313836	/data/lib/docker/defaultVolumes/task_3600_g0_dbpaas-metadb_minidbpaas</div><div class="line">27278692	/data/lib/docker/defaultVolumes/task_3604_g0_ark-metadb_miniDBPaaS-MetaDB_1</div><div class="line">27277004	/data/lib/docker/defaultVolumes/task_3603_g0_ark-metadb_miniDBPaaS-MetaDB_1</div><div class="line">27275736	/data/lib/docker/defaultVolumes/task_3542_g0_ark-metadb_miniDBPaaS-MetaDB</div><div class="line">27271428	/data/lib/docker/defaultVolumes/task_3597_g0_ark-metadb_miniDBPaaS-MetaDB</div><div class="line">27270840	/data/lib/docker/defaultVolumes/task_3603_g0_dbpaas-metadb_minidbpaas_1</div><div class="line">27270492	/data/lib/docker/defaultVolumes/task_3603_g0_dbpaas-metadb_minidbpaas</div><div class="line">27270468	/data/lib/docker/defaultVolumes/task_3600_g0_ark-metadb_miniDBPaaS-MetaDB</div><div class="line">27270252	/data/lib/docker/defaultVolumes/task_3535_g0_ark-metadb_miniDBPaaS-MetaDB</div><div class="line">27270244	/data/lib/docker/defaultVolumes/task_3538_g0_ark-metadb_miniDBPaaS-MetaDB</div><div class="line">27270244	/data/lib/docker/defaultVolumes/task_3536_g0_ark-metadb_miniDBPaaS-MetaDB</div><div class="line">25312404	/data/lib/docker/defaultVolumes/task_3477_g0_dncs-server_middleware-dncs_2</div></pre></td></tr></table></figure>
<p>/data/lib/docker/defaultVolumes 参数是方舟默认volume存放的目录（一般是docker的存储路径下 –graph=/data/lib/docker) ，第一列是大小，后面是容器名</p>
<p>volume路径在物理机上也有可能是 /var/lib/docker 或者 /mw/mvdocker/ 之类的路径下，这个要依据安装参数来确定，可以用如下命令来找到这个路径：</p>
<p><code>sudo systemctl status docker -l | grep --color graph</code></p>
<p>结果如下，红色参数后面的路径就是docker 安装目录，到里面去找带volume的字眼：</p>
<p><img src="https://plantegg.oss-cn-beijing.aliyuncs.com/images/oss/9b7e489576840f72a5bd13e969abce39.png" alt="image.png"></p>
<p>找到 volume很大的文件件后同样可以进到这个文件夹中执行如下命令快速发现大文件：</p>
<p><code>du . --max-depth=2</code></p>
<h3 id="方法三-容器的系统日志没有限制大小"><a href="#方法三-容器的系统日志没有限制大小" class="headerlink" title="方法三 容器的系统日志没有限制大小"></a>方法三 容器的系统日志没有限制大小</h3><p>这种情况只针对2017年上半年之前的部署环境，后面部署的环境默认都控制了这些日志不会超过150M</p>
<p>按照方法二的描述先找到docker 安装目录，cd 进去，然后 ： </p>
<p><code>du ./containers --max-depth=2</code></p>
<p>就很快找到那个大json格式的日志文件了,然后执行清空这个大文件的内容：</p>
<p><code>echo &#39;&#39; | sudo tee 大文件名</code></p>
<h3 id="一些其他可能占用空间的地方"><a href="#一些其他可能占用空间的地方" class="headerlink" title="一些其他可能占用空间的地方"></a>一些其他可能占用空间的地方</h3><ul>
<li>机器上镜像太多，可以删掉一些没用的： sudo docker images -q | xargs sudo docker rmi </li>
<li>机器上残留的volume太多，删：sudo docker volume ls -q | xargs sudo docker volume rm</li>
<li>物理文件被删了，但是还有进程占用这个文件句柄，导致文件对应的磁盘空间没有释放，检查： lsof |　grep deleted  如果这个文件非常大的话，只能通过重启这个进程来真正释放磁盘空间</li>
</ul>
<hr>
<h4 id="检查是否restart能支持只重启deamon，容器还能正常运行："><a href="#检查是否restart能支持只重启deamon，容器还能正常运行：" class="headerlink" title="检查是否restart能支持只重启deamon，容器还能正常运行："></a>检查是否restart能支持只重启deamon，容器还能正常运行：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$sudo docker info | grep Restore</div><div class="line">Live Restore Enabled: true</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2017/01/14/通过分析tcp包来确认服务调用的响应时间/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weibo @plantegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/14/通过分析tcp包来确认服务调用的响应时间/" itemprop="url">通过分析tcp包来确认服务调用的响应时间</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-14T10:30:03+08:00">
                2017-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP/" itemprop="url" rel="index">
                    <span itemprop="name">TCP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="通过分析tcp包来确认服务调用的响应时间"><a href="#通过分析tcp包来确认服务调用的响应时间" class="headerlink" title="通过分析tcp包来确认服务调用的响应时间"></a>通过分析tcp包来确认服务调用的响应时间</h1><h2 id="不需要在应用中打点，不限定于具体语言（php、cpp、java都可以）-分析服务调用的响应时间"><a href="#不需要在应用中打点，不限定于具体语言（php、cpp、java都可以）-分析服务调用的响应时间" class="headerlink" title="不需要在应用中打点，不限定于具体语言（php、cpp、java都可以）, 分析服务调用的响应时间"></a>不需要在应用中打点，不限定于具体语言（php、cpp、java都可以）, 分析服务调用的响应时间</h2><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当时的问题，客户现场不管怎么样增加应用机器，tps就是上不去，同时增加应用机器后，增加的机器CPU还都能被用完，但是tps没有变化（这点比较奇怪，也就是cpu用的更多了，tps没变化），客户感觉 整体服务调用慢，数据库没有慢查询，不知道到具体时间花在哪里，各个环节都尝试过增加服务器（或提升配置），但是问题一直得不到解决</div></pre></td></tr></table></figure>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="数据库服务器网卡中断瓶颈导致rtt非常高，进一步导致每个Query的ResponseTime非常高（图中左边都是出问题、右边都是问题解决后的响应时间）"><a href="#数据库服务器网卡中断瓶颈导致rtt非常高，进一步导致每个Query的ResponseTime非常高（图中左边都是出问题、右边都是问题解决后的响应时间）" class="headerlink" title="数据库服务器网卡中断瓶颈导致rtt非常高，进一步导致每个Query的ResponseTime非常高（图中左边都是出问题、右边都是问题解决后的响应时间）"></a>数据库服务器网卡中断瓶颈导致rtt非常高，进一步导致每个Query的ResponseTime非常高（图中左边都是出问题、右边都是问题解决后的响应时间）</h3><blockquote>
<p>通过程序把每个请求、响应时间等数据分析出来并存入数据库中（缺一个图形展示界面，有图形展示界面后会更直观）</p>
<p>图一中是每一秒中的平均 rtt 时间（round trip time）</p>
</blockquote>
<p><img src="/images/951413iMgBlog/image-20220524155218723.png" alt="image"></p>
<h4 id="问题修复后数据库每个查询的平均响应时间从47毫秒下降到了4-5毫秒"><a href="#问题修复后数据库每个查询的平均响应时间从47毫秒下降到了4-5毫秒" class="headerlink" title="问题修复后数据库每个查询的平均响应时间从47毫秒下降到了4.5毫秒"></a>问题修复后数据库每个查询的平均响应时间从47毫秒下降到了4.5毫秒</h4><blockquote>
<p>图中的每一行都是是一个查询的数据库执行时间</p>
</blockquote>
<p><img src="/images/951413iMgBlog/image-20220524155221182.png" alt="image"></p>
<h4 id="从wireshark中也可以看到类似的rtt不正常（超过150ms的比较多）"><a href="#从wireshark中也可以看到类似的rtt不正常（超过150ms的比较多）" class="headerlink" title="从wireshark中也可以看到类似的rtt不正常（超过150ms的比较多）"></a>从wireshark中也可以看到类似的rtt不正常（超过150ms的比较多）</h4><p><img src="/images/951413iMgBlog/image.png" alt="image"></p>
<h4 id="从wireshark中也可以看到类似的rtt正常-99-都在10ms以内）"><a href="#从wireshark中也可以看到类似的rtt正常-99-都在10ms以内）" class="headerlink" title="从wireshark中也可以看到类似的rtt正常(99%都在10ms以内）"></a>从wireshark中也可以看到类似的rtt正常(99%都在10ms以内）</h4><p><img src="/images/951413iMgBlog/image-20220524155217000.png" alt="image"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>实际上通过抓包发现所有发往后面的SQL查询(请求链路：app -&gt; slb -&gt; drds -&gt; slb -&gt;rds) ，在app上抓包发现每个请求发出去到收到结果平均需要差不多100ms（无论SQL复杂与否），通过统计网络往返时间（rtt）发现rtt非常高，好多都是50ms以上。<br>降低压力比较rtt，发现rtt降到了20ms以内，同时SQL响应时间也相应地减短了。<br>已经排除了drds到rds响应慢的问题，问题应该在slb或者drds上，进一步发现drds（16Core 16GMem）绑定网卡中断的cpu用到了95%以上，尝试绑定到多个cpu内核，似乎ecs不支持，接下来将配置，增加多个低配置的drds来解决问题。</p>
</blockquote>
<p><strong>简单来说ecs默认网卡中断只能用到一个核，如果ecs配置太高，网卡中断会成为瓶颈，导致rtt变高、不稳定</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2017/01/01/top_linux_commands/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weibo @plantegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/top_linux_commands/" itemprop="url">最牛B的Linux Shell命令</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T17:30:03+08:00">
                2017-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="最牛B的Linux-Shell命令"><a href="#最牛B的Linux-Shell命令" class="headerlink" title="最牛B的Linux Shell命令"></a>最牛B的Linux Shell命令</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Shell作为Unix系操作系统当中最有魅力且不可或缺的组件，经过数十载的洗礼不仅没有被淘汰，而且愈加变得成熟稳健，究其原因，大概因为它是个非常稳固的粘合剂，能够把大量功能强大的组件任意配搭，总能很好很快地完成用户的任务。</p>
<p>本文的一些命令很可能看起来是“雕虫小技”，我们只好仰慕一下Shell大牛了，但是有些细节我会稍加发掘加以说明，遇到有趣的地方希望能博您一笑了。</p>
<h2 id="1-以sudo运行上条命令"><a href="#1-以sudo运行上条命令" class="headerlink" title="1.以sudo运行上条命令"></a>1.以sudo运行上条命令</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>sudo</strong> <strong>!!</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>大家应该都知sudo，不解释。但通常出现的情况是，敲完命令执行后报错才发现忘了sudo。这时候，新手用户就会：按上箭头，按左箭头，盯着光标回到开始处，输入sudo，回车；高手用户就蛋定多了，按Ctrl-p，按Ctrl-a，输入sudo，回车。</p>
<p>这里介绍这个是天外飞仙级别的，对，就直接sudo !!。</p>
<p>当然这几种解决方式效果是完全一样的，只是款不一样，嗯，不解释。</p>
<p>两个感叹号其实是bash的一个特性，称为事件引用符（event designators）。!!其实相当于!-1，引用前一条命令，当然也可以!-2，!-50。默认情况下bash会在~/.bash_history文件内记录用户执行的最近500条命令，history命令可以显示这些命令。</p>
<p>关于事件引用符的更多用法可以深入阅读<a href="http://www.catonmat.net/blog/the-definitive-guide-to-bash-command-line-history/" target="_blank" rel="external">The Definitive Guide to Bash Command Line History</a>。</p>
<h2 id="2-以HTTP方式共享当前文件夹的文件"><a href="#2-以HTTP方式共享当前文件夹的文件" class="headerlink" title="2.以HTTP方式共享当前文件夹的文件"></a>2.以HTTP方式共享当前文件夹的文件</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ python -m  SimpleHTTPServer 8080</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这命令启动了Python的SimpleHTTPServer模块，考虑到Python在绝大多数的Linux发行版当中都默认安装，所以这个命令很可能是最简单的跨平台传文件的方法。</p>
<p>命令执行后将在本机8000端口开放HTTP服务，在其他能访问本机的机器的浏览器打开ttp://ip:8000即打开一个目录列表，点击即可下载。</p>
<p>python3的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python3 -m http.server 8080</div></pre></td></tr></table></figure>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#最近一天修改的md文档</div><div class="line">find . -maxdepth 1 -type f -mtime -1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -not -name &quot;temp.md&quot; -exec ls -lh &quot;&#123;&#125;&quot; \;</div><div class="line"></div><div class="line">find . -size 0  -type f -exec ls -lh &quot;&#123;&#125;&quot; \;</div><div class="line"></div><div class="line">#clean the big file, but exclude spill dir</div><div class="line">sudo find /home/admin/ -not -path &quot;*/spill/*&quot; -type f -size +3G -exec cp /dev/null &#123;&#125; \;</div><div class="line">sudo find /home/admin/ -type f -name &quot;*.hprof&quot; -mtime +1 -exec rm -f &#123;&#125; \;</div><div class="line">#clean the spill temp file which before 7 days ago</div><div class="line">sudo find /home/admin/ -type f -mtime +7 -exec cp /dev/null &#123;&#125; \;</div><div class="line">sudo find /home/admin/logs/ -type f -mtime +7 -exec rm -f &#123;&#125; \;</div><div class="line">sudo find /var/log/ -type f -size +500M -exec cp /dev/null &#123;&#125; \;</div><div class="line"></div><div class="line">#备份匹配的文件</div><div class="line">find . -name &apos;*.ibd&apos; | grep tpcc1000 | grep -v drds_global | xargs -I&#123;&#125; cp --path &#123;&#125; /tmp/bak/</div><div class="line"></div><div class="line">#将yaml 备份，保留目录结构</div><div class="line">find . -name &apos;*.yaml&apos; | xargs -I&#123;&#125; cp --path &#123;&#125; /tmp/ren/</div><div class="line"></div><div class="line"></div><div class="line">find $srcDir -maxdepth 1 -type f -mtime -$1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -not -name &quot;temp.md&quot; -exec ls -lh &quot;&#123;&#125;&quot; \;</div><div class="line"></div><div class="line">find $srcDir -maxdepth 1 -type f -mtime -$1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -not -name &quot;temp.md&quot; -exec cp &quot;&#123;&#125;&quot; ./source/_posts/ \;</div><div class="line"></div><div class="line">#sudo find /media/sf_D_DRIVE/case/ -maxdepth 1 -type f -mtime -$1 -name &quot;*.md&quot; -not -name &quot;template.md&quot; -print -exec cp &quot;&#123;&#125;&quot; ./source/_posts/ \;</div></pre></td></tr></table></figure>
<p>xargs 参数：</p>
<blockquote>
<p>-I [replace-str]：将xargs的输出每一项参数，单独赋值给后面的命令，参数需要用指定的代替字符串replace-str代替，也就是说replace-str不可缺省，必须显示指明，可以使用{} $ @等符号，其主要作用是<strong>当xargs command后有多个参数时，调整参数位置</strong></p>
</blockquote>
<h2 id="xargs-传参数"><a href="#xargs-传参数" class="headerlink" title="xargs 传参数"></a>xargs 传参数</h2><blockquote>
<p>ls /xx | xargs -t -I{}  cp {} /tmp/{}</p>
</blockquote>
<p>-t ： 打印内容，去掉\n之后的字符串</p>
<p>-I :  后面定义占位符，上例子是{}  ，后面命令行中可以多次使用占位符</p>
<p>挂载多台苹果的例子</p>
<blockquote>
<p> idevice_id -l|xargs -t -I{} mkdir {};idevice_id -l |xargs -t -I{} ifuse {} {}</p>
</blockquote>
<p>批量执行docker exec</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible -i host.ini all -m shell -a &quot;docker ps -a | grep pxd-tpcc | grep dn | cut -d &apos; &apos; -f 1 | xargs  -I&#123;&#125; docker exec &#123;&#125; bash -c \&quot;myc -e &apos;shutdown&apos;\&quot;&quot;</div></pre></td></tr></table></figure>
<p>批量推送镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images |grep &quot;docker.io:5000&quot; | awk &apos;&#123; print $1&quot;:&quot;$2 &#125;&apos; | xargs -I &#123;&#125; docker push &#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h2><p>vim中默认匹配：abc.*d 是贪婪匹配，也就是尽可能长地匹配，改用 abc.{-}d 匹配到第一个 d字符就结束</p>
<blockquote>
<p>贪婪模式是: .*</p>
<p>非贪婪模式是: .\{-}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">\&#123;n,m&#125; Matches n to m of the preceding atom, as many as possible</div><div class="line">\&#123;n&#125; Matches n of the preceding atom</div><div class="line">\&#123;n,&#125; Matches at least n of the preceding atom, as many as possible</div><div class="line">\&#123;,m&#125; Matches 0 to m of the preceding atom, as many as possible</div><div class="line">\&#123;&#125; Matches 0 or more of the preceding atom, as many as possible (like *)</div><div class="line">*/\&#123;-*</div><div class="line">\&#123;-n,m&#125; matches n to m of the preceding atom, as few as possible</div><div class="line">\&#123;-n&#125; matches n of the preceding atom</div><div class="line">\&#123;-n,&#125; matches at least n of the preceding atom, as few as possible</div><div class="line">\&#123;-,m&#125; matches 0 to m of the preceding atom, as few as possible</div><div class="line">\&#123;-&#125; matches 0 or more of the preceding atom, as few as possibles</div></pre></td></tr></table></figure>
<p>grep 非贪婪匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep --color -P &quot;agHost.*?,&quot; test.table  //匹配 agHost后带有多个任意字符直到第一个 逗号 结束，-P表示用 perl 的匹配语法，而perl默认是不支持贪婪的</div><div class="line"></div><div class="line">grep --color -P &quot;agHost.*?,&quot; test.table  //-o 只打印匹配部分</div></pre></td></tr></table></figure>
<h2 id="MacOS-sed-删除行"><a href="#MacOS-sed-删除行" class="headerlink" title="MacOS sed 删除行"></a>MacOS sed 删除行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//查找匹配的行：|      |                               |</div><div class="line">grep -E &quot;\| [[:space:]]*\| [[:space:]]*\|&quot; top_linux_commands.md -B3</div><div class="line"></div><div class="line">//删除行 -i &quot;.bak&quot;是直接操作文件并添加.bak作为备份文件名称，如果不需要备份文件，则使用-i &quot;&quot;</div><div class="line">sed -i &apos;&apos; -e  &apos;/\| [[:space:]]*\| [[:space:]]*\|/d&apos;  top_linux_commands.md</div><div class="line"></div><div class="line">//先备份文件为.bak, 再删除行 -i &quot;.bak&quot;是添加.bak作为备份文件名称</div><div class="line">sed -i &apos;.bak&apos; &apos;s/\| [[:space:]]*\| [[:space:]]*\|/d&apos;  top_linux_commands.md</div></pre></td></tr></table></figure>
<h2 id="ps-查看进程"><a href="#ps-查看进程" class="headerlink" title="ps 查看进程"></a>ps 查看进程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -Tfp pid // -T 展开进程下的线程 -f full -p pid</div></pre></td></tr></table></figure>
<h2 id="循环按行处理"><a href="#循环按行处理" class="headerlink" title="循环按行处理"></a>循环按行处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">while  read i ; do echo $i ; done &lt;./prometheus.list</div></pre></td></tr></table></figure>
<h2 id="3-在以普通用户打开的vim当中保存一个root用户文件"><a href="#3-在以普通用户打开的vim当中保存一个root用户文件" class="headerlink" title="3.在以普通用户打开的vim当中保存一个root用户文件"></a>3.在以普通用户打开的vim当中保存一个root用户文件</h2><table>
<thead>
<tr>
<th>1</th>
<th>:<strong>w</strong> <strong>!sudo</strong> <strong>tee</strong> <strong>%</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这题目读起来纠结，其实是很常见的，常常忘记了sudo就直接用vim编辑/etc内的文件，（不过也不一定，vim发现保存的文件无法保存时候会提示）等编辑好了，保存时候才发现没权限。曲线方法是先保存个临时文件，退出后再sudo cp回去。不过实际上在vim里面可以直接完成这个过程的，命令就是如此。</p>
<p>查阅vim的文档（输入:help :w），会提到命令:w!{cmd}，让vim执行一个外部命令{cmd}，然后把当前缓冲区的内容从stdin传入。</p>
<p>tee是一个把stdin保存到文件的小工具。</p>
<p>而%，是vim当中一个只读寄存器的名字，总保存着当前编辑文件的文件路径。</p>
<p>所以执行这个命令，就相当于从vim外部修改了当前编辑的文件，好完工。</p>
<h2 id="4-切换回上一个目录"><a href="#4-切换回上一个目录" class="headerlink" title="4.切换回上一个目录"></a>4.切换回上一个目录</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>cd</strong> -</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>应该不少人都知道这个，横杆-代表上一个目录的路径。</p>
<p>实际上cd -就是cd $OLDPWD的简写，bash的固定变量$OLDPWD总保存着之前一个目录的路径。</p>
<p>相对地，$PWD总保存着当前目录的路径。这些变量在编写shell脚本时候相当有用。</p>
<h2 id="5-替换上一条命令中的一个短语"><a href="#5-替换上一条命令中的一个短语" class="headerlink" title="5.替换上一条命令中的一个短语"></a>5.替换上一条命令中的一个短语</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ ^foo^bar^</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>又是另外一个事件引用符（event designator），可以把上一条命令当中的foo替换成bar。</p>
<p>在需要重复运行调试一道长长的命令，需要测试某个参数时候，用这个命令会比较实用；但多数人会首先选择按上箭头提出上道命令，再移动光标去修改某参数，这样更直观，但效率上就不够使用引用符高，而且在脚本中用这个方法可以简化很多。</p>
<p>这道命令的原始样式应该是这样的:</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>!!</strong>:s<strong>/</strong>foo<strong>/</strong>bar<strong>/</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>本文一开始介绍过!!，后面的一段大家应该很熟悉，vim、sed的替换操作都是这样的语法。</p>
<p>关于事件引用符的更多用法可以深入阅读<a href="http://www.catonmat.net/blog/the-definitive-guide-to-bash-command-line-history/" target="_blank" rel="external">The Definitive Guide to Bash Command Line History</a></p>
<h2 id="6-快速备份一个文件"><a href="#6-快速备份一个文件" class="headerlink" title="6.快速备份一个文件"></a>6.快速备份一个文件</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>cp</strong>  filename<strong>{</strong>,.bak<strong>}</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这道命令把filename文件拷贝成filename.bak，大家应该在一些比较复杂的安装教程里面见过这样的用法。其原理就在于bash对大括号的展开操作，filename{,.bak}这一段会被展开成filename filename.bak再传给cp，于是就有了备份的命令了。</p>
<p>大括号在bash里面是一个排列的意义，可以试试这个：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>echo</strong> <strong>{</strong>a,b,c<strong>}{</strong>a,b,c<strong>}{</strong>a,b,c<strong>}</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>将输出三个集合的全排列:</p>
<p>aaa aab aac aba abb abc aca acb acc</p>
<p>baa bab bac bba bbb bbc bca bcb bcc</p>
<p>caa cab cac cba cbb cbc cca ccb ccc</p>
<p>关于shell当中的集合操作，可深入阅读<a href="http://www.catonmat.net/blog/set-operations-in-unix-shell/" target="_blank" rel="external">“Set Operations in the Unix Shell”</a></p>
<h2 id="7-免密码ssh登录主机"><a href="#7-免密码ssh登录主机" class="headerlink" title="7.免密码ssh登录主机"></a>7.免密码ssh登录主机</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ ssh-copy-id remote-machine</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这个命令把当前用户的公钥串写入到远程主机的~/.ssh/authorized_keys内，这样下次使用ssh登录的时候，远程主机就直接根据这串密钥完成身份校验，不再询问密码了。前提是你当前用户有生成了公钥，默认是没有的，先执行ssh-keygen试试吧！</p>
<p>这个命令如果用手工完成，是这样的：</p>
<table>
<thead>
<tr>
<th>1  2  3</th>
<th>your-machine$ scp  ~/.ssh/identity.pub  remote-machine:  your-machine$ ssh  remote-machine  remote-machine$ cat  identity.pub &gt;&gt; ~/.ssh/authorized_keys</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如果你想删掉远程主机上的密钥，直接打开authorized_keys，搜索你的用户名，删除那行，即可。</p>
<h2 id="8-抓取Linux桌面的视频"><a href="#8-抓取Linux桌面的视频" class="headerlink" title="8.抓取Linux桌面的视频"></a>8.抓取Linux桌面的视频</h2><table>
<thead>
<tr>
<th>1</th>
<th>$ <strong>ffmpeg</strong> -f x11grab -s  wxga -r 25  -i :0.0 -sameq <strong>/</strong>tmp<strong>/</strong>out.mpg</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>我们在一些视频网站上看到别人的3D桌面怎么怎么酷的视频，通常就是这么来的，ffmpeg可以直接解码X11的图形，并转换到相应输出格式。</p>
<p>ffmpeg的通常用法是，根据一堆参数，输出一个文件，输出文件通常放最后，下面解析下几个参数：</p>
<p>-f x11grab 指定输入类型。因为x11的缓冲区不是普通的视频文件可以侦测格式，必须指定后ffmpeg才知道如何获得输入。</p>
<p>-s wxga 设置抓取区域的大小。wxga是1366*768的标准说法，也可以换成-s 800×600的写法。</p>
<p>-r 25 设置帧率，即每秒抓取的画面数。</p>
<p>-i :0.0 设置输入源，本地X默认在0.0</p>
<p>-sameq 保持跟输入流一样的图像质量，以用来后期处理。</p>
<p>至于其他ffmpeg的用法，可以参考下面两篇文章：</p>
<p>·    <a href="http://www.catonmat.net/blog/how-to-extract-audio-tracks-from-youtube-videos/" target="_blank" rel="external">How to Extract Audio Tracks from YouTube Videos</a></p>
<p>·    <a href="http://www.catonmat.net/blog/converting-youtube-flvs-to-a-better-format-with-ffmpeg" target="_blank" rel="external">Converting YouTube Flash Videos to a Better Format with ffmpeg</a></p>
<p>后记</p>
<p>说Shell是一种编程语言，可能有些尴尬，虽然很多人每天都在用Shell，但从来没见它荣登TIOBE编程语言排行榜之类的，可以说毫无名分，因为很多用户没意识到它是一种语言，只当做这是一个能够很好完成任务的工具，基本得理所当然，就好像GUI程序的菜单、按钮一样。</p>
<p>掌握Shell，通常能够让任务在数秒钟内完成，这就让Shell跟C、Perl、Python这些语言区别开来，没人否认后者更能胜任更多的任务，但是他们是在不同的层面上去做，Shell依赖大量的系统组件黏合调用，而后者依赖各种库，各所擅长不同的应用领域，比喻就是，Shell是混凝土，可以很方便地粘合一些建筑组件而成为稳固的高楼大厦；但同样是粘合剂，粘玻璃窗、粘书报、粘皮鞋，混凝土是绝对不合适的，Shell并不擅长一些细致操作，比如它连浮点运算都不支持，更别提什么图形运算什么的。但这并不妨碍Shell来帮我们完成很多粗重任务。</p>
<p>Shell的工作方式，大多数入门用户会觉得枯燥难学，而所谓的经典教材也离不开《Advanced Bash-Scripting》、《Bash Guide for Beginners》，但类似本文这样的一些“雕虫小技”因为难登大雅之堂绝不会收录进去。这情况如果象国外一些unix用户比较多的地方会有很好改善，即使是新手，偶尔看看别人的操作都能“偷师”一手，我编译本系列文章其实也就希望稍微改善一下这个状况。</p>
<h2 id="1-用你最喜欢的编辑器来敲命令"><a href="#1-用你最喜欢的编辑器来敲命令" class="headerlink" title="1.用你最喜欢的编辑器来敲命令"></a>1.用你最喜欢的编辑器来敲命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>command</strong> <strong>&lt;</strong>CTRL-x  CTRL-e<strong>&gt;</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>在已经敲完的命令后按<ctrl-x ctrl-e="">，会打开一个你指定的编辑器（比如vim，通过环境变量$EDITOR指定），里面就是你刚输入的命令，然后爱怎么编辑就怎么编辑吧，特别是那些参数异常复杂的程序，比如mencoder/ffmpeg，一个命令动辄3、4行的，要修改其中的参数，这个方法最合适不过了，保存退出后自动执行这个程序。</ctrl-x></p>
<p>实际上这是<a href="http://tiswww.case.edu/php/chet/readline/rltop.html" target="_blank" rel="external">readline库</a>的功能，在默认情况下，bash使用的是emacs模式的命令行操作方式，<ctrl-x ctrl-e="">是调用这个功能的一个绑定。如果你习惯使用vi模式，按<esc v="">可以实现同样功能。</esc></ctrl-x></p>
<p>如果你喜欢别的编辑器，可以在~/.bashrc里面放上比如export EDITOR=nano的命令。</p>
<p>另外一个修改命令的方法是使用fc命令（Fix Command），在编辑器里面打开上一句命令。我们的<a href="http://www.isspy.com/most_useful_linux_commands_1/" target="_blank" rel="external">第一辑连载</a>提过一个^foo^bar^命令可以用fc来实现：fc -s foo=bar。</p>
<h2 id="2-清空或创建一个文件"><a href="#2-清空或创建一个文件" class="headerlink" title="2.清空或创建一个文件"></a>2.清空或创建一个文件</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>&gt;</strong> file.txt</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>>在shell里面是标准输出重定向符，即把（前部个命令的）命令行输出转往一个文件内，但这里没有“前部命令”，输出为空，于是就覆盖（或创建）成一个空文件了。</p>
<p>有些脚本的写法是:&gt;file.txt，因为:是bash默认存在的空函数。</p>
<p>单纯创建文件也可以用$touch file.txt，touch本来是用作修改文件的时间戳，但如果文件不存在，就自动创建了。</p>
<h2 id="3-用ssh创建端口转发通道"><a href="#3-用ssh创建端口转发通道" class="headerlink" title="3.用ssh创建端口转发通道"></a>3.用ssh创建端口转发通道</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> -N  -L2001:remotehost:80 user<strong>@</strong>somemachine</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这个命令在本机打开了2001端口，对本机2001端口的请求通过somemachine作为跳板，转到remotehost的80端口上。</p>
<p>实现效果跟术语反向代理是相似的，实际上就是端口转发，注意上面的描述涉及了3台主机，但当然somemachine可以变成localhost。</p>
<p>这个命令比较抽象，但有时候是很有用的，比如因为众所周知的原因国内的IP的80端口无法使用，又或者公司的防火墙只给外网开了ssh端口，需要访问内部服务器一个web应用，以及需要访问某些限定了来源IP的服务，就可以用上这个方法了。</p>
<p>举一个具体例子，运行：</p>
<table>
<thead>
<tr>
<th>1  2</th>
<th><strong>ssh</strong> -f -N -L  0.0.0.0:443:twitter.com:443 shell.cjb.net  <strong>ssh</strong> -f -N -L  0.0.0.0:80:twitter.com:80 shell.cjb.net</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>然后在/etc/hosts里面添加127.0.0.1 twitter.com，好吧剩下的你懂的。</p>
<p>当然通常做这个功能的反向代理，应该要用squid、nginx之类，ssh就算是轻量级的尝试吧！</p>
<h2 id="4-重置终端"><a href="#4-重置终端" class="headerlink" title="4.重置终端"></a>4.重置终端</h2><table>
<thead>
<tr>
<th>1</th>
<th>reset</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如果你试过不小心cat了某个二进制文件，很可能整个终端就傻掉了，可能不会换行，没法回显，大堆乱码之类的，这时候敲入reset回车，不管命令有没有显示，就能回复正常了。</p>
<p>实际上reset命令只是输出了一些特殊字符，我们看BusyBox里面最简单的reset程序的实现：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>printf(“<strong>\033</strong>c<strong>\033</strong>(K<strong>\033</strong>[J<strong>\033</strong>[0m<strong>\033</strong>[?25h”);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>输出的这些字符对Shell是有特殊意义的：</p>
<p>·    \033c: “ESC c” – 发送重置命令;</p>
<p>·    \033(K: “ESC ( K” – 重载终端的字符映射;</p>
<p>·    \033[J: “ESC [ J” – 清空终端内容;</p>
<p>·    \033[0m: “ESC [ 0 m” – 初始化字符显示属性;</p>
<p>·    \033[?25h: “ESC [ ? 25 h” – 让光标可见;</p>
<p>其中<em>字符显示属性</em>经常用来设定打印字符的颜色等，可参考<a href="http://linuxshellaccount.blogspot.com/2008/03/using-color-in-linux-or-unix-shell.html" target="_blank" rel="external">这个博文</a>。</p>
<h2 id="5-在午夜的时候执行某命令"><a href="#5-在午夜的时候执行某命令" class="headerlink" title="5.在午夜的时候执行某命令"></a>5.在午夜的时候执行某命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>echo</strong> cmd **\</th>
<th>** at  midnight</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>说的就是at这个组件，通常跟cron相提并论，不过at主要用于定时一次性任务，而cron定时周期性任务。</p>
<p>at的参数比较人性化，跟英语语法一样，可以tomorrow, next week之类的，详细的查看手册man at。</p>
<h2 id="6-远程传送麦克风语音"><a href="#6-远程传送麦克风语音" class="headerlink" title="6.远程传送麦克风语音"></a>6.远程传送麦克风语音</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>dd</strong> if=<strong>/</strong>dev<strong>/</strong>dsp  **\</th>
<th><strong> </strong>ssh<strong>  username</strong>@<strong>host </strong>dd<strong> of=</strong>/<strong>dev</strong>/**dsp</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>没错就是实现一个喊话器的功能。</p>
<p>/dev/dsp是Linux下声卡的文件映射（Digital Signal Proccessor），从其中读数据就是录音，往里面写数据就是播放，相当简单！</p>
<p>dd是常用的数据拷贝程序，如果不同时指定if、of，就直接使用stdin/stdout来传输。</p>
<p>如果你没有远程主机，可以试试这样：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>dd</strong> if=<strong>/</strong>dev<strong>/</strong>dsp  of=<strong>/</strong>dev<strong>/</strong>dsp</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>直接回放麦克风的声音，只是有一点延时。</p>
<p>但是如果有别的程序正在使用声卡，这个方法就不凑效了，因为一般的声卡都不允许多个音频流同时处理，可以借用alsa组件的工具，arecord跟aplay:</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>arecord</strong> **\</th>
<th><strong> </strong>ssh<strong> username</strong>@<strong>host  </strong>aplay**</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>本地回放就是：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>arecord</strong> **\</th>
<th><strong> </strong>aplay**</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如果你想吓吓别人：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>cat</strong> <strong>/</strong>dev<strong>/</strong>urandom **\</th>
<th><strong>  </strong>ssh<strong> username</strong>@<strong>host </strong>aplay**</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h2 id="7-映射一个内存目录"><a href="#7-映射一个内存目录" class="headerlink" title="7.映射一个内存目录"></a>7.映射一个内存目录</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>mount</strong> -t tmpfs -o size=1024m  tmpfs <strong>/</strong>mnt<strong>/</strong>ram</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这个命令开了一块1G内存来当目录用。不过放心，如果里面没文件，是不会占用内存的，用多少占多少。</p>
<p>不过一般来说没必要手动挂载，因为多数发行版都会在fstab内预留了一个内存目录，挂载在/dev/shm，直接使用即可；</p>
<p>最常见的用途是用内存空间来放Firefox的配置，可以让慢吞吞的FF快很多，参见Shellex的博文：<a href="http://shellex.info/speeding-up-firefox-with-tmpfs/" target="_blank" rel="external">用tmpfs让Firefox在内存中飞驰</a>，以及后来的改进：<a href="http://shellex.info/speeding-up-firefox-with-tmpfs-ii/" target="_blank" rel="external">用tmpfs让Firefox在内存中飞驰II</a>，其中提到的脚本来自<a href="http://www.linuxized.com/2009/05/speeding-up-firefox-with-tmpfs-and-automatic-rsync/" target="_blank" rel="external">speeding up firefox with tmpfs and automatic rsync</a>。</p>
<p>那个破烂LinuxQQ也可以用这个方法，减少因为大量磁盘IO导致的问题。</p>
<h2 id="8-用diff对比远程文件跟本地文件"><a href="#8-用diff对比远程文件跟本地文件" class="headerlink" title="8.用diff对比远程文件跟本地文件"></a>8.用diff对比远程文件跟本地文件</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> user<strong>@</strong>host <strong>cat</strong> <strong>/</strong>path<strong>/</strong>to<strong>/</strong>remotefile  **\</th>
<th><strong> </strong>diff<strong>  </strong>/<strong>path</strong>/<strong>to</strong>/**localfile -</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>diff通常的用法是从参数读入两个文件，而命令里面的-则是指从stdin读入了。</p>
<p>善用ssh可以让web开发减少很多繁琐，还有比如sshfs，可以从<strong>编辑**</strong>-<strong><strong>上传</strong></strong>-<strong><strong>编辑</strong></strong>-<strong>**上传</strong>的人工循环里面解脱出来。</p>
<h2 id="9-查看系统中占用端口的进程"><a href="#9-查看系统中占用端口的进程" class="headerlink" title="9.查看系统中占用端口的进程"></a>9.查看系统中占用端口的进程</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>netstat</strong> -tulnp</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Netstat是很常用的用来查看Linux网络系统的工具之一，这个参数可以背下来：</p>
<p>·    -t: 显示TCP链接信息</p>
<p>·    -u: 显示UDP链接信息</p>
<p>·    -l: 显示监听状态的端口</p>
<p>·    -n: 直接显示ip，不做名称转换</p>
<p>·    -p: 显示相应的进程PID以及名称（要root权限）</p>
<p>如果要查看关于sockets更详细占用信息等，可以使用lsof工具。</p>
<h2 id="1-更友好的显示当前挂载的文件系统"><a href="#1-更友好的显示当前挂载的文件系统" class="headerlink" title="1. 更友好的显示当前挂载的文件系统"></a>1. 更友好的显示当前挂载的文件系统</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th>`<strong>mount</strong> **</th>
<th>** column -t`</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这条命令适用于任何文件系统，column 用于把输出结果进行列表格式化操作，这里最主要的目的是让大家熟悉一下 columnt 的用法。 下面是单单使用 mount 命令的结果：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5</code></th>
<th><code>$ **mount**`` ``**/**dev**/**root on **/** **type** ext3 **(**rw**)**``**/**proc on **/**proc **type** proc **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home on **/**home **type** ext3 **(**rw,noatime**)**</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>而加了 column -t 命令后就成为这样了：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5</code></th>
<th>`$ <strong>mount</strong> **</th>
<th><strong> column -t<code> </code></strong>/<strong>dev</strong>/<strong>root on </strong>/<strong> </strong>type<strong> ext3 </strong>(<strong>rw</strong>)<strong>``</strong>/<strong>proc on </strong>/<strong>proc </strong>type<strong> proc </strong>(<strong>rw</strong>)<strong>``</strong>/<strong>dev</strong>/<strong>mapper</strong>/<strong>lvmraid-home on </strong>/<strong>home </strong>type<strong> ext3 </strong>(<strong>rw,noatime</strong>)**`</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>另外你可加上列名称来改善输出结果</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6</code></th>
<th>`$ <strong>(echo</strong> “DEVICE - PATH - TYPE FLAGS” <strong>&amp;&amp;</strong> <strong>mount)</strong> **</th>
<th><strong> column -t<code>``DEVICE          -  PATH  -   TYPE  FLAGS</code></strong>/<strong>dev</strong>/<strong>root         on </strong>/<strong>   </strong>type<strong> ext3  </strong>(<strong>rw</strong>)<strong>``</strong>/<strong>proc           on </strong>/<strong>proc </strong>type<strong> proc  </strong>(<strong>rw</strong>)<strong>``</strong>/<strong>dev</strong>/<strong>mapper</strong>/<strong>lvmraid-home on </strong>/<strong>home </strong>type<strong> ext3  </strong>(<strong>rw,noatime</strong>)**`</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>列2和列4并不是很友好，我们可以用 awk 来再处理一下</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6</code></th>
<th>`$ <strong>(echo</strong> “DEVICE PATH TYPE FLAGS” <strong>&amp;&amp;</strong> <strong>mount</strong> **</th>
<th><strong> </strong>awk<strong> ‘$2=$4=””;1’</strong>)<strong> </strong></th>
<th><strong> column -t<code>``DEVICE          PATH  TYPE  FLAGS</code></strong>/<strong>dev</strong>/<strong>root         </strong>/<strong>   ext3  </strong>(<strong>rw</strong>)<strong>``</strong>/<strong>proc           </strong>/<strong>proc proc  </strong>(<strong>rw</strong>)<strong>``</strong>/<strong>dev</strong>/<strong>mapper</strong>/<strong>lvmraid-home </strong>/<strong>home ext3  </strong>(<strong>rw,noatime</strong>)**`</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>最后我们可以设置一个别名，为 nicemount</p>
<table>
<thead>
<tr>
<th><code>1</code></th>
<th>`$ nicemount<strong>()</strong> <strong>{</strong> <strong>(echo</strong> “DEVICE PATH TYPE FLAGS” <strong>&amp;&amp;</strong> <strong>mount</strong> **</th>
<th><strong> </strong>awk<strong> ‘$2=$4=””;1’</strong>)<strong> </strong></th>
<th><strong> column -t; </strong>}**`</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>试一下</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6</code></th>
<th><code>$ nicemount`` ``DEVICE          PATH  TYPE  FLAGS``**/**dev**/**root         **/**   ext3  **(**rw**)**``**/**proc           **/**proc proc  **(**rw**)**``**/**dev**/**mapper**/**lvmraid-home **/**home ext3  **(**rw,noatime**)**</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h2 id="2-运行前一个-Shell-命令，同时用-“bar”-替换掉命令行中的每一个-“foo”"><a href="#2-运行前一个-Shell-命令，同时用-“bar”-替换掉命令行中的每一个-“foo”" class="headerlink" title="2. 运行前一个 Shell 命令，同时用 “bar” 替换掉命令行中的每一个 “foo”"></a>2. 运行前一个 Shell 命令，同时用 “bar” 替换掉命令行中的每一个 “foo”</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**!!**:gs**/**foo**/**bar</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><code>!!</code> 表示重复执行上一条命令，并用 <code>:gs/foo/bar</code> 进行替换操作。 关于 <code>!!</code> 这个用法在<a href="http://www.isspy.com/most_useful_linux_commands_1/" target="_blank" rel="external">前一篇文章中</a>已有详细的介绍。</p>
<h2 id="3-实时某个目录下查看最新改动过的文件"><a href="#3-实时某个目录下查看最新改动过的文件" class="headerlink" title="3. 实时某个目录下查看最新改动过的文件"></a>3. 实时某个目录下查看最新改动过的文件</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**watch** -d -n 1 &#39;df; ls -FlAt /path&#39;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>watch 是实时监控工具，-d 参数会高亮显示变化的区域，-n 1 参数表示刷新间隔为 1 秒。 df; ls -FlAt /path 运行了两条命令，df 是输出磁盘使用情况，<code>ls -FlAt</code> 则列出 /path 下面的所有文件。 ls -FlAt 的参数详解：</p>
<p>·    -F 在文件后面加一个文件符号表示文件类型，共有 <em>/=&gt;@|</em> <em>这几种类型，</em> 表示可执行文件，/ 表示目录，= 表示接口( sockets) ，&gt; 表示门， @ 表示符号链接， | 表示管道。</p>
<p>·    -l 以列表方式显示</p>
<p>·    -A 显示 <code>.</code> 和 <code>..</code></p>
<p>·    -t 根据时间排序文件</p>
<h2 id="4-通过-SSH-挂载远程主机上的文件夹"><a href="#4-通过-SSH-挂载远程主机上的文件夹" class="headerlink" title="4. 通过 SSH 挂载远程主机上的文件夹"></a>4. 通过 SSH 挂载远程主机上的文件夹</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>sshfs name**@**server:**/**path**/**to**/**folder **/**path**/**to**/**mount**/**point</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这条命令可以让你通过 SSH 加载远程主机上的文件系统为本地磁盘，前提是你需要安装 FUSE 及 sshfs 这两个软件。 <strong>译者注</strong>：关于 sshfs 实际上我之前写过一篇文章介绍过，详见<a href="http://wowubuntu.com/sshfs.html" target="_blank" rel="external">在 Ubuntu 上使用 sshfs 映射远程 ssh 文件系统为本地磁盘</a>。 卸载的话使用 fusermount 或 umount 命令：</p>
<table>
<thead>
<tr>
<th><code>1``2</code></th>
<th><code>$ fusermount -u **/**path**/**to**/**mount**/**point``*# umount /path/to/mount/point*</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h2 id="5-通过-DNS-来读取-Wikipedia-的词条"><a href="#5-通过-DNS-来读取-Wikipedia-的词条" class="headerlink" title="5. 通过 DNS 来读取 Wikipedia 的词条"></a>5. 通过 DNS 来读取 Wikipedia 的词条</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**dig** +short txt .wp.dg.cx</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这也许是最有趣的一条技巧了，David Leadbeater 创建了一个 <a href="https://dgl.cx/wikipedia-dns" target="_blank" rel="external">DNS 服务器</a>，通过它当你查询一个 TXT 记录类型时，会返回一条来自于 Wikipedia 的简短的词条文字，这是<a href="https://dgl.cx/2008/11/wpdns-pres/" target="_blank" rel="external">他的介绍</a>。 这里有一个样例，来查询 “hacker” 的含义：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6``7``8</code></th>
<th><code>$ **dig** +short txt hacker.wp.dg.cx`` ``&quot;Hacker may refer to: Hacker (computer security), someone involved``in computer security/insecurity, Hacker (programmer subculture), a``programmer subculture originating in the US academia in the 1960s,``which is nowadays mainly notable for the free software/” “open``source movement, Hacker (hobbyist), an enthusiastic home computer``hobbyist http://a.vu/w:Hacker&quot;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这里使用了 dig 命令，这是标准的用来查询 DNS 的系统管理工具，+short 参数是让其仅仅返回文字响应，txt 则是指定查询 TXT 记录类型。 更简单的做法是你可以为这个技巧创建一个函数：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5</code></th>
<th><code>wiki**()** **{** **dig** +short txt $1.wp.dg.cx; **}**``*#**然后试试吧：*``wiki hacker`` ``&quot;Hacker may refer to: Hacker (computer security), …&quot;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如果你不想用 dig ，也可以用 host 命令：</p>
<table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>host -t txt hacker.wp.dg.cx</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>另外在Twitter上看过某人的创意，用普通的dns来作为程序版本更新的查询服务器：设定域名<code>software-version-check.example.com</code>的A记录为<code>1.2.40.3</code>，对比自己的版本号，嗯，有更新了！</p>
<h2 id="6-用-Wget-的递归方式下载整个网站"><a href="#6-用-Wget-的递归方式下载整个网站" class="headerlink" title="6. 用 Wget 的递归方式下载整个网站"></a>6. 用 Wget 的递归方式下载整个网站</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup wget --random-wait -nc -q -r -l 0 --reject=html -np -e robots=off -U Mozilla www.example.com &amp;</div></pre></td></tr></table></figure>
<p>参数解释： <em>–random-wait</em> <em>等待</em> <em>0.5</em> <em>到</em> <em>1.5</em> <em>秒的时间来进行下一次请求</em> -r 开启递归检索 <em>-e robots=off</em> <em>忽略</em> <em>robots.txt</em> -U Mozilla 设置 User-Agent 头为 Mozilla 其它一些有用的参数：</p>
<p>·    –limit-rate=20K 限制下载速度为 20K</p>
<p>·    -o logfile.txt 记录下载日志</p>
<p>·    -l 0 删除深度（默认为5）</p>
<p>·    -wait=1h 每下载一个文件后等待1小时</p>
<p>-np 不下载父目录 </p>
<p>–reject=html 不下载html</p>
<p>-nc 本地已有的不再下载</p>
<h2 id="7-复制最后使用的命令中的参数"><a href="#7-复制最后使用的命令中的参数" class="headerlink" title="7. 复制最后使用的命令中的参数"></a>7. 复制最后使用的命令中的参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Ctrl + . or ESC + . </div><div class="line">command + . //macos</div></pre></td></tr></table></figure>
<p>这个快捷键只能工作于 shell 的 emacs 编辑模式，它可以从最后使用的命令行中复制参数到当前命令行中，下面是一个样例：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5</code></th>
<th><code>$ **echo** a b c``a b c`` ``$ **echo**``$ **echo** c</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>你可以重复执行该快捷键，以便获取自已需要的参数， 以下是样例：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6``7``8``9``10</code></th>
<th><code>$ **echo** 1 2 3``1 2 3``$ **echo** a b c``a b c`` ``$ **echo**``$ **echo** c`` ``$ **echo** again``$ **echo** 3</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>另外，假如你想指定第1个或第2个，或者是第 n 个参数的话，可以按 ALT + 1 (或 ESC + 1) 或 ALT + 2 (或 ESC +2) 这样形式的快捷键。 以下是样例：</p>
<table>
<thead>
<tr>
<th><code>1``2``3``4``5``6``7``8``9``10</code></th>
<th><code>$ **echo** a b c``a b c`` ``$ **echo**``$ **echo** a``a`` ``$ **echo**``$ **echo** b``b</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>查看<a href="http://www.catonmat.net/blog/bash-emacs-editing-mode-cheat-sheet/" target="_blank" rel="external">Emacs Editing Mode Keyboard Shortcuts</a>一文获取更多类似的快捷键。</p>
<h2 id="8-执行一条命令但不保存到-history-中"><a href="#8-执行一条命令但不保存到-history-中" class="headerlink" title="8. 执行一条命令但不保存到 history 中"></a>8. 执行一条命令但不保存到 history 中</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>$ **command**</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这条命令可运行于最新的 Bash shell 里，在其它 shell 中没测试过。 通过在命令行前面添加一个空格，就可以阻止这条命令被保存到 bash history (~/.bash_history) 文件中，这个行为可以通过 $HISTIGNORE shell 变量来控制。我的设置是 HISTIGNORE=”&amp;:[ ]*” ，表示不保存重复的命令到 history 中，并且不保存以空格开头的命令行。$HISTIGNORE 中的值以冒号分隔。 如果你的命令内包含密码，比如<code>mysqladmin</code>，不把它记录在历史当中是好主义。 深入了解的话，可进一步看此文<a href="http://www.catonmat.net/blog/the-definitive-guide-to-bash-command-line-history/" target="_blank" rel="external">The Definitive Guide to Bash Command Line History</a></p>
<h2 id="9-显示当前目录中所有子目录的大小"><a href="#9-显示当前目录中所有子目录的大小" class="headerlink" title="9. 显示当前目录中所有子目录的大小"></a>9. 显示当前目录中所有子目录的大小</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**du** -h --max-depth=1</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>–max-depth=1 参数可以让 du 命令显示当前目录下 1 级子目录的统计信息，当然你也可以把 1 改为 2 ，进一步显示 2 级子目录的统计信息，可以灵活运用。而 -h 参数则是以 Mb 、G 这样的单位来显示大小。 <strong>译者注</strong>：在此推荐一个小工具 ncdu ，可以更方便的达到此效果。</p>
<h2 id="10-显示消耗内存最多的-10-个运行中的进程，以内存使用量排序"><a href="#10-显示消耗内存最多的-10-个运行中的进程，以内存使用量排序" class="headerlink" title="10. 显示消耗内存最多的 10 个运行中的进程，以内存使用量排序"></a>10. 显示消耗内存最多的 10 个运行中的进程，以内存使用量排序</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th>`<strong>ps</strong> aux **</th>
<th><strong> </strong>sort<strong> -nk +4 </strong></th>
<th><strong> </strong>tail**`</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>显然这并不是最好的方法，但它确实用起还不错。 这是一个典型的管道应用，通过 ps aux 来输出到 sort 命令，并用 sort 排序列出 4 栏，再进一步转到 tail 命令，最终输出 10 行显示使用内存最多的进程情况。 假如想要发现哪个进程使用了大量内存的话，我通常会使用 htop 或 top 而非 ps 。</p>
<h2 id="11-用-python-快速开启一个-SMTP-服务"><a href="#11-用-python-快速开启一个-SMTP-服务" class="headerlink" title="11. 用 python 快速开启一个 SMTP 服务"></a>11. 用 python 快速开启一个 SMTP 服务</h2><table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>python -m smtpd -n -c DebuggingServer localhost:1025</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这是一个用 Python 标准库 smtpd （用 -m smtpd 指定) 实现在简易 SMTP 服务，运行于 1025 端口 。 另外三个参数的解释： <em>-n</em> <em>参数让</em> <em>Python</em> <em>不要进行</em> <em>setuid (</em> <em>改变用户）为</em> <em>“nobody”</em> <em>，也就是说直接用你的帐号来运行</em> -c DebuggingServer 参数是让 Python 运行时在屏幕上输出调试及运行信息 * localhost:1025 参数则是让 Python 在本地的 1025 端口上开启 SMTP 服务 另外，假如你想让程序运行于标准的 25 的端口上的话，你必须使用 sudo 命令，因为只有 root 才能在 1-1024 端口上开启服务。如下：</p>
<table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>**sudo** python -m smtpd -n -c DebuggingServer localhost:25</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>1.查看ascii码表</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>man</strong> 7 ascii</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>很多人初学编程都会接触到ascii码的概念，有时候为了查某个符号的ascii值，可能还得翻箱倒柜找出当年的课本？<a href="http://www.kernel.org/doc/man-pages/" target="_blank" rel="external">Linux Manpage</a>里面其实包含了很多类似的实用资料，上述命令就能很详细的方式解释ascii编码，<a href="http://www.kernel.org/doc/man-pages/online/pages/man7/ascii.7.html" target="_blank" rel="external">当然这里还有在线版</a>。</p>
<p>man命令的第二个参数是区域码，用来区分索引词的范围，比如printf，在C标准库里面的printf跟bash当中的printf是不同的，前者的查询是man 3 printf，后者是man 1 printf。如果这个区域码省略，就会从1开始搜索，直到找到为止。</p>
<p>命令man man可以<a href="http://www.kernel.org/doc/man-pages/online/pages/man7/man-pages.7.html" target="_blank" rel="external">看到详细的解释</a>。</p>
<p>manpages里面还有一些有趣而且实用的资料，可能鲜为人知：</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man1/intro.1.html" target="_blank" rel="external">man 1 intro </a>– 一篇对从未接触过Linux的用户的简明教程。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/syscalls.2.html" target="_blank" rel="external">man 2 syscalls </a>– 内核系统请求的列表，按内核版本注释分类，系统编程必备。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/select_tut.2.html" target="_blank" rel="external">man 2 select_tut </a>– 关于select()系统请求的教程。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/string.3.html" target="_blank" rel="external">man 3 string </a>– 在头文件内的所有函数。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/stdio.3.html" target="_blank" rel="external">man 3 stdio </a>– 关于头文件的使用，标准输入/输出库的说明。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/errno.3.html" target="_blank" rel="external">man 3 errno </a>– 所有errorno的取值及说明。（C语言内类似其他语言的异常告知机制）</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man4/console_codes.4.html" target="_blank" rel="external">man 4 console_codes </a>– Linux的终端控制码及其使用解释。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man4/full.4.html" target="_blank" rel="external">man 4 full </a>– 介绍/dev/full这个总是处于“满”状态的磁盘。（对应/dev/null这个总是空的设备）</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man5/proc.5.html" target="_blank" rel="external">man 5 proc </a>– 介绍/proc下的文件系统。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man5/filesystems.5.html" target="_blank" rel="external">man 5 filesystems </a>– 各种Linux文件系统。</p>
<p>第7区里面的资料通常最酷：</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/bootparam.7.html" target="_blank" rel="external">man 7 bootparam </a>– 详细解释内核启动参数。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/charsets.7.html" target="_blank" rel="external">man 7 charsets </a>– 解释各种语言的编码集。（gbk，gb2312等）</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/glob.7.html" target="_blank" rel="external">man 7 glob </a>– 解释glob文件名管理机制的工作过程。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/hier.7.html" target="_blank" rel="external">man 7 hier </a>– 解释Linux文件系统结构各个部分的作用。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/operator.7.html" target="_blank" rel="external">man 7 operator </a>– C语言的运算符的列表。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/regex.7.html" target="_blank" rel="external">man 7 regex </a>– 介绍正则表达式。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/suffixes.7.html" target="_blank" rel="external">man 7 suffixes </a>– 常见文件后缀名的列表跟解释。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/time.7.html" target="_blank" rel="external">man 7 time </a>– Linux的时钟机制解释。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/units.7.html" target="_blank" rel="external">man 7 units </a>– 数值单位及其数值的解释。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/utf8.7.html" target="_blank" rel="external">man 7 utf8 </a>– 描述UTF-8编码。</p>
<p>·    <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/url.7.html" target="_blank" rel="external">man 7 url </a>– 解释URL、URI、URN等的标准。</p>
<p>2.简易计时器</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>time</strong> <strong>read</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>运行命令开始算起，到结束时按一下Enter，就显示出整个过程的时间，精确到ms级别。</p>
<p>time是用来计算一个进程在运行到结束过程耗费多少时间的程序，它的输出通常有三项：</p>
<table>
<thead>
<tr>
<th>1  2  3  4  5</th>
<th>$ time ls /opt  …  real    0m0.008s  user    0m0.003s  sys    0m0.007s</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>real指整个程序对真实世界而言运行所需时间，user指程序在用户空间运行的时间，sys指程序对系统调用锁占用时间。</p>
<p>read本来是一个读取用户输入的命令，常见用法是read LINE，用户输入并回车后，键入的内容就被保存到$LINE变量内，但在键入回车前，这个命令是一直阻塞的。</p>
<p>可见time read这命令灵活地利用了操作系统的阻塞。用这个命令来测试一壶水多久煮滚应该是不错的。</p>
<p>3.远程关掉一台Windows机器</p>
<table>
<thead>
<tr>
<th>1</th>
<th>net rpc shutdown -I  IP_ADDRESS -U username<strong>%</strong>password</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Windows平台上的net命令是比较强大的，因为其后台是一个RPC类的系统服务，大家应该看过win下用net use \ip\ipc$ *这样一个命令建立IPC空连接，入侵主机的事情。</p>
<p>Linux下的net命令是samba组件的程序，通常包含在smbclient内，可以跟windows主机的文件、打印机共享等服务进行通讯，但是也支持rpc命令。</p>
<p>上述命令就是在远程Windows主机上执行了shutdown命令。当然这不一定成功，关系到win主机上面的安全设置。net命令能够控制到win主机就是了。</p>
<h2 id="4-在一个子shell中运行一个命令"><a href="#4-在一个子shell中运行一个命令" class="headerlink" title="4.在一个子shell中运行一个命令"></a>4.在一个子shell中运行一个命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>(cd</strong> <strong>/</strong>tmp <strong>&amp;&amp;</strong> <strong>ls)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>当然这只是演示，要查看目录当然可以ls /tmp。</p>
<p>好处就是不会改变当前shell的目录，以及如果命令中设计环境变量，也不会对当前shell有任何修改。</p>
<p>在Shell编程中还有很多使用上引号来括住一个命令：<code>ls /tmp</code>，这也是子shell过程。可是上引号的方法无法嵌套，而使用小括号的方法可以，一个比较纠结的例子是：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>echo</strong> $<strong>(echo</strong> -e \x$<strong>(printf</strong>  “%x” 65<strong>))</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>5.利用中间管道嵌套使用SSH</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> -t host_A <strong>ssh</strong> host_B</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如果目标机器host_B处于比较复杂的网络环境，本机无法直接访问，但另外一台host_A能够访问到host_B，而且也能被本机访问到，那上述命令就解决了方便登录host_B的问题。</p>
<p>但理论上这个过程是可以无限嵌套的，比如：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>ssh</strong> -t host1 <strong>ssh</strong> -t  host2 <strong>ssh</strong> -t  host3 <strong>ssh</strong> -t  host4 …</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>嗯那神马FBI CIA的，有本事来捉我吧～</p>
<p>6.清空屏幕</p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>&lt;</strong>CTRL+l<strong>&gt;</strong>;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这个跟之前介绍的reset命令重置终端的作用有些类似，其实都只是发送一段控制序列，让终端的显示复位。</p>
<p>还可以这样运行：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>tput <strong>clear</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>tput是专门用来控制终端的一个小工具，也挺强大的，详细信息运行man tput查看。</p>
<h2 id="7-我想知道一台服务器什么时候重启完"><a href="#7-我想知道一台服务器什么时候重启完" class="headerlink" title="7.我想知道一台服务器什么时候重启完"></a>7.我想知道一台服务器什么时候重启完</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>ping</strong> -a IP</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>系统管理员最常做的事情是重启系统。但是服务器的重启过程往往得花上好几分钟，什么你的服务器4个scsi卡？16个硬盘？系统是Redhat？还完全安装所有组件？好吧，它重启的时间都够你吃顿饭了，所以我很想知道它什么时候回来。</p>
<p>ping命令有个audible ping参数，-a，当它终于ping通你的服务器时会让小喇叭叫起来。</p>
<h2 id="8-列出你最常用的10条命令"><a href="#8-列出你最常用的10条命令" class="headerlink" title="8.列出你最常用的10条命令"></a>8.列出你最常用的10条命令</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>history</strong> **\</th>
<th><strong> </strong>awk<strong> ‘{a[$2]++}END{for(i  in a){print a[i] “ “ i}}’ </strong>\</th>
<th><strong>  </strong>sort<strong> -rn  </strong>\</th>
<th><strong> </strong>head**</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这行命令组合得很妙：</p>
<p>history输出用户了命令历史；awk统计并输出列表；sort排序；head截出前10行。</p>
<h2 id="9-检查Gmail新邮件"><a href="#9-检查Gmail新邮件" class="headerlink" title="9.检查Gmail新邮件"></a>9.检查Gmail新邮件</h2><table>
<thead>
<tr>
<th>1  2  3  4  5  6</th>
<th>curl -u you<strong>@</strong>gmail.com –silent  “<a href="https://mail.google.com/mail/feed/atom" target="_blank" rel="external">https://mail.google.com/mail/feed/atom</a>“  **\</th>
<th><strong>   </strong>perl** -ne  \   ‘      print “Subject: $1 “ if /<title>(.+?)&lt;\/title&gt;/  &amp;&amp; $title++;      print “(from $1)\n” if /<email>(.+?)&lt;\/email&gt;/;   ‘</email></title></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Gmail的一个特色是支持Atom feed输出邮件列表，所以总是见到很多Gmail邮件提醒器之类的，因为开发特简单，atom很方便。</p>
<p>这里只是利用了perl的正则来解析atom（sed/awk也能做到）。</p>
<h2 id="10-用Telnet看《星球大战》"><a href="#10-用Telnet看《星球大战》" class="headerlink" title="10.用Telnet看《星球大战》"></a>10.用Telnet看《星球大战》</h2><table>
<thead>
<tr>
<th>1</th>
<th>telnet towel.blinkenlights.nl</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>没什么好解释的，就是ASCII艺术之一。如果你有ipv6连接，还能看到彩色版的。牛吧？</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2016/10/12/ss用法大全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weibo @plantegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/12/ss用法大全/" itemprop="url">就是要你懂网络监控--ss用法大全</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-12T15:30:03+08:00">
                2016-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/network/" itemprop="url" rel="index">
                    <span itemprop="name">network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="就是要你懂网络监控–ss用法大全"><a href="#就是要你懂网络监控–ss用法大全" class="headerlink" title="就是要你懂网络监控–ss用法大全"></a>就是要你懂网络监控–ss用法大全</h1><p>ss是Socket Statistics的缩写。</p>
<p>netstat命令大家肯定已经很熟悉了，但是在2001年的时候netstat 1.42版本之后就没更新了，之后取代的工具是ss命令，是iproute2 package的一员。</p>
<blockquote>
<p>​    rpm -ql iproute | grep ss<br>​    /usr/sbin/ss</p>
</blockquote>
<p>netstat的替代工具是nstat，当然netstat的大部分功能ss也可以替代</p>
<p>ss可以显示跟netstat类似的信息，但是速度却比netstat快很多，netstat是基于/proc/net/tcp获取 TCP socket 的相关统计信息，用strace跟踪一下netstat查询tcp的连接，会看到他open的是/proc/net/tcp的信息。ss快的秘密就在于它利用的是TCP协议的tcp_diag模块，而且是从内核直接读取信息，<strong>当内核不支持  tcp_diag 内核模块时，会回退到 /proc/net/tcp 模式</strong>。</p>
<p>/proc/net/snmp 存放的是系统启动以来的累加值，netstat -s 读取它<br>/proc/net/tcp  是存放目前活跃的tcp连接的统计值，连接断开统计值清空， ss -it 读取它</p>
<h2 id="ss-查看Buffer窗口"><a href="#ss-查看Buffer窗口" class="headerlink" title="ss 查看Buffer窗口"></a><a href="https://access.redhat.com/discussions/3624151" target="_blank" rel="external">ss 查看Buffer窗口</a></h2><p>ss参数说明<a href="https://man7.org/linux/man-pages/man8/ss.8.html" target="_blank" rel="external">权威参考</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">-m, --memory  //查看每个连接的buffer使用情况</div><div class="line">              Show socket memory usage. The output format is:</div><div class="line"></div><div class="line">              skmem:(r&lt;rmem_alloc&gt;,rb&lt;rcv_buf&gt;,t&lt;wmem_alloc&gt;,tb&lt;snd_buf&gt;,</div><div class="line">                            f&lt;fwd_alloc&gt;,w&lt;wmem_queued&gt;,o&lt;opt_mem&gt;,</div><div class="line">                            bl&lt;back_log&gt;,d&lt;sock_drop&gt;)</div><div class="line"></div><div class="line">              &lt;rmem_alloc&gt;</div><div class="line">                     the memory allocated for receiving packet</div><div class="line"></div><div class="line">              &lt;rcv_buf&gt;</div><div class="line">                     the total memory can be allocated for receiving</div><div class="line">                     packet</div><div class="line"></div><div class="line">              &lt;wmem_alloc&gt;</div><div class="line">                     the memory used for sending packet (which has been</div><div class="line">                     sent to layer 3)</div><div class="line"></div><div class="line">              &lt;snd_buf&gt;</div><div class="line">                     the total memory can be allocated for sending</div><div class="line">                     packet</div><div class="line"></div><div class="line">              &lt;fwd_alloc&gt;</div><div class="line">                     the memory allocated by the socket as cache, but</div><div class="line">                     not used for receiving/sending packet yet. If need</div><div class="line">                     memory to send/receive packet, the memory in this</div><div class="line">                     cache will be used before allocate additional</div><div class="line">                     memory.</div><div class="line"></div><div class="line">              &lt;wmem_queued&gt;</div><div class="line">                     The memory allocated for sending packet (which has</div><div class="line">                     not been sent to layer 3)</div><div class="line"></div><div class="line">              &lt;ropt_mem&gt;</div><div class="line">                     The memory used for storing socket option, e.g.,</div><div class="line">                     the key for TCP MD5 signature</div><div class="line"></div><div class="line">              &lt;back_log&gt;</div><div class="line">                     The memory used for the sk backlog queue. On a</div><div class="line">                     process context, if the process is receiving</div><div class="line">                     packet, and a new packet is received, it will be</div><div class="line">                     put into the sk backlog queue, so it can be</div><div class="line">                     received by the process immediately</div><div class="line"></div><div class="line">              &lt;sock_drop&gt;</div><div class="line">                     the number of packets dropped before they are de-</div><div class="line">                     multiplexed into the socket</div></pre></td></tr></table></figure>
<p>The entire print format of <code>ss -m</code> is given in the source:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">      printf(&quot; skmem:(r%u,rb%u,t%u,tb%u,f%u,w%u,o%u&quot;,</div><div class="line">               skmeminfo[SK_MEMINFO_RMEM_ALLOC],</div><div class="line">               skmeminfo[SK_MEMINFO_RCVBUF],</div><div class="line">               skmeminfo[SK_MEMINFO_WMEM_ALLOC],</div><div class="line">               skmeminfo[SK_MEMINFO_SNDBUF],</div><div class="line">               skmeminfo[SK_MEMINFO_FWD_ALLOC],</div><div class="line">               skmeminfo[SK_MEMINFO_WMEM_QUEUED],</div><div class="line">               skmeminfo[SK_MEMINFO_OPTMEM]);</div><div class="line"></div><div class="line">        if (RTA_PAYLOAD(tb[attrtype]) &gt;=</div><div class="line">                (SK_MEMINFO_BACKLOG + 1) * sizeof(__u32))</div><div class="line">                printf(&quot;,bl%u&quot;, skmeminfo[SK_MEMINFO_BACKLOG]);</div><div class="line"></div><div class="line">        if (RTA_PAYLOAD(tb[attrtype]) &gt;=</div><div class="line">                (SK_MEMINFO_DROPS + 1) * sizeof(__u32))</div><div class="line">                printf(&quot;,d%u&quot;, skmeminfo[SK_MEMINFO_DROPS]);</div><div class="line"></div><div class="line">        printf(&quot;)&quot;);</div><div class="line">        </div><div class="line">        </div><div class="line">net/core/sock.c line:3095</div><div class="line">void sk_get_meminfo(const struct sock *sk, u32 *mem)</div><div class="line">&#123;</div><div class="line">	memset(mem, 0, sizeof(*mem) * SK_MEMINFO_VARS);</div><div class="line"></div><div class="line">	mem[SK_MEMINFO_RMEM_ALLOC] = sk_rmem_alloc_get(sk);</div><div class="line">	mem[SK_MEMINFO_RCVBUF] = sk-&gt;sk_rcvbuf;</div><div class="line">	mem[SK_MEMINFO_WMEM_ALLOC] = sk_wmem_alloc_get(sk);</div><div class="line">	mem[SK_MEMINFO_SNDBUF] = sk-&gt;sk_sndbuf;</div><div class="line">	mem[SK_MEMINFO_FWD_ALLOC] = sk-&gt;sk_forward_alloc;</div><div class="line">	mem[SK_MEMINFO_WMEM_QUEUED] = sk-&gt;sk_wmem_queued;</div><div class="line">	mem[SK_MEMINFO_OPTMEM] = atomic_read(&amp;sk-&gt;sk_omem_alloc);</div><div class="line">	mem[SK_MEMINFO_BACKLOG] = sk-&gt;sk_backlog.len;</div><div class="line">	mem[SK_MEMINFO_DROPS] = atomic_read(&amp;sk-&gt;sk_drops);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/951413iMgBlog/image-20210604120011898.png" alt="image-20210604120011898"></p>
<p>–memory/-m ： 展示buffer窗口的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#ss -m | xargs -L 1 | grep &quot;ESTAB&quot; | awk &apos;&#123; if($3&gt;0 || $4&gt;0) print $0 &#125;&apos;</div><div class="line">tcp ESTAB 0 31 10.97.137.1:7764 10.97.137.2:41019 skmem:(r0,rb7160692,t0,tb87040,f1792,w2304,o0,bl0)</div><div class="line">tcp ESTAB 0 193 ::ffff:10.97.137.1:sdo-tls ::ffff:10.97.137.2:55545 skmem:(r0,rb369280,t0,tb87040,f1792,w2304,o0,bl0)</div><div class="line">tcp ESTAB 0 65 ::ffff:10.97.137.1:splitlock ::ffff:10.97.137.2:47796 skmem:(r0,rb369280,t0,tb87040,f1792,w2304,o0,bl0)</div><div class="line">tcp ESTAB 0 80 ::ffff:10.97.137.1:informer ::ffff:10.97.137.3:49279 skmem:(r0,rb369280,t0,tb87040,f1792,w2304,o0,bl0)</div><div class="line">tcp ESTAB 0 11 ::ffff:10.97.137.1:acp-policy ::ffff:10.97.137.2:41607 skmem:(r0,rb369280,t0,tb87040,f1792,w2304,o0,bl0)</div><div class="line"></div><div class="line">#ss -m -n | xargs -L 1 | grep &quot;tcp EST&quot; | grep &quot;t[1-9]&quot;</div><div class="line">tcp ESTAB 0 281 10.97.169.173:32866 10.97.170.220:3306 skmem:(r0,rb4619516,t2304,tb87552,f1792,w2304,o0,bl0)</div></pre></td></tr></table></figure>
<p><img src="/images/oss/4a09503e6c6e84c25e026248a1b3ebb6.png" alt="image.png"></p>
<p>如上图，tb指可分配的发送buffer大小，不够还可以动态调整（应用没有写死的话），w[The memory allocated for sending packet (which has not been sent to layer 3)]已经预分配好了的size，t[the memory used for sending packet (which has been sent to layer 3)] , 似乎 w总是等于大于t？</p>
<p>example:</p>
<p><img src="/images/oss/4ed3d8aab6ef3ee45decda75e534baab.png" alt="image.png"></p>
<p>对172.16.210.17和172.16.160.1之间的带宽限速50MB后观察(带宽限制后，发送buffer就很容易被撑满了）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">ss -m | xargs -L 1 | grep <span class="string">"tcp EST"</span> | awk <span class="string">'&#123; if($3&gt;0 || $4&gt;0) print $0 &#125;'</span></span></div><div class="line">Netid State Recv-Q Send-Q Local Address:Port Peer Address:Port</div><div class="line">tcp ESTAB 1431028 0 172.16.210.17:30082 172.16.160.1:4847 skmem:(r2066432,rb2135508,t0,tb46080,f2048,w0,o0,bl0,d72)</div><div class="line">tcp ESTAB 1195628 0 172.16.210.17:30086 172.16.160.1:4847 skmem:(r1742848,rb1915632,t8,tb46080,f190464,w0,o0,bl0,d187)</div><div class="line">tcp ESTAB 86416 0 172.16.210.17:40470 172.16.160.1:4847 skmem:(r127232,rb131072,t0,tb46080,f3840,w0,o0,bl0,d16)</div><div class="line">tcp ESTAB 1909826 0 172.16.210.17:40476 172.16.160.1:4847 skmem:(r2861568,rb2933688,t2,tb46080,f26112,w0,o0,bl0,d15)</div><div class="line">tcp ESTAB 758312 0 172.16.210.17:40286 172.16.160.1:4847 skmem:(r1124864,rb1177692,t0,tb46080,f1536,w0,o0,bl0,d17)</div><div class="line">tcp ESTAB 2238720 0 172.16.210.17:40310 172.16.160.1:4847 skmem:(r3265280,rb3334284,t0,tb46080,f3328,w0,o0,bl0,d30)</div><div class="line">tcp ESTAB 88172 0 172.16.210.17:40508 172.16.160.1:4847 skmem:(r128000,rb131072,t0,tb46080,f3072,w0,o0,bl0,d16)</div><div class="line">tcp ESTAB 87700 0 172.16.210.17:41572 172.16.160.1:4847 skmem:(r130560,rb131072,t0,tb46080,f512,w0,o0,bl0,d10)</div><div class="line">tcp ESTAB 4147293 0 172.16.210.17:40572 172.16.160.1:4847 skmem:(r6064896,rb6291456,t2,tb46080,f75008,w0,o0,bl0,d27)</div><div class="line">tcp ESTAB 1610940 0 172.16.210.17:30100 172.16.160.1:4847 skmem:(r2358784,rb2533092,t6,tb46080,f82432,w0,o0,bl0,d304)</div><div class="line">tcp ESTAB 4216156 0 172.16.210.17:30068 172.16.160.1:4847 skmem:(r6091008,rb6291456,t0,tb46080,f3840,w0,o0,bl0,d112)</div><div class="line">tcp ESTAB 87468 0 172.16.210.17:40564 172.16.160.1:4847 skmem:(r127232,rb131072,t0,tb46080,f3840,w0,o0,bl0,d16)</div><div class="line">tcp ESTAB 0 84608 172.16.210.17:3306 10.100.7.27:43114 skmem:(r0,rb65536,t8352,tb131072,f75648,w92288,o0,bl0,d0)</div><div class="line">tcp ESTAB 4141872 0 172.16.210.17:40584 172.16.160.1:4847 skmem:(r6050560,rb6291456,t2,tb46080,f19712,w0,o0,bl0,d14)</div><div class="line"><span class="meta"></span></div><div class="line">$<span class="bash">ss -itn</span></div><div class="line">State       Recv-Q Send-Q   Local Address:Port                  Peer Address:Port</div><div class="line">ESTAB       965824 0        172.16.210.17:19310                 172.16.160.1:4847</div><div class="line">         cubic wscale:9,7 rto:215 rtt:14.405/0.346 ato:160 mss:1440 rcvmss:1460 advmss:1460 cwnd:10 bytes_acked:1324584 bytes_received:2073688144 segs_out:91806 segs_in:1461520 data_segs_out:4824 data_segs_in:1456130 send 8.0Mbps lastsnd:545583 lastrcv:545276 lastack:13173 pacing_rate 16.0Mbps delivery_rate 8.9Mbps app_limited busy:9071ms rcv_rtt:1.303 rcv_space:164245 minrtt:1.293</div><div class="line">ESTAB       0      84371    172.16.210.17:3306                  10.100.7.147:59664</div><div class="line">         cubic wscale:7,7 rto:217 rtt:16.662/0.581 ato:40 mss:1448 rcvmss:976 advmss:1448 cwnd:375 ssthresh:19 bytes_acked:5087795046 bytes_received:1647 segs_out:3589314 segs_in:358086 data_segs_out:3589313 data_segs_in:8 send 260.7Mbps lastsnd:6 lastrcv:1177745 lastack:4 pacing_rate 312.8Mbps delivery_rate 32.9Mbps busy:1176476ms rwnd_limited:1717ms(0.1%) sndbuf_limited:159867ms(13.6%) unacked:37 retrans:0/214 rcv_space:14600 notsent:32055 minrtt:7.945</div><div class="line">ESTAB       0      83002    172.16.210.17:3306                   10.100.7.28:34066</div><div class="line">         cubic wscale:7,7 rto:215 rtt:14.635/0.432 ato:40 mss:1448 rcvmss:976 advmss:1448 cwnd:144 ssthresh:144 bytes_acked:972464708 bytes_received:1466 segs_out:671667 segs_in:94369 data_segs_out:671666 data_segs_in:8 send 114.0Mbps lastsnd:1 lastrcv:453365 lastack:1 pacing_rate 136.8Mbps delivery_rate 24.0Mbps busy:453493ms sndbuf_limited:200ms(0.0%) unacked:23 rcv_space:14600 notsent:49698 minrtt:9.937</div><div class="line">ESTAB       1239616 0        172.16.210.17:41592                 172.16.160.1:4847</div><div class="line">         cubic wscale:9,7 rto:216 rtt:15.754/0.775 ato:144 mss:1440 rcvmss:1460 advmss:1460 cwnd:10 bytes_acked:20321 bytes_received:1351071 segs_out:269 segs_in:1091 data_segs_out:76 data_segs_in:988 send 7.3Mbps lastsnd:339339 lastrcv:337401 lastack:10100 pacing_rate 14.6Mbps delivery_rate 1.0Mbps app_limited busy:1214ms rcv_rtt:227.156 rcv_space:55581 minrtt:11.38</div><div class="line">ESTAB       3415748 0        172.16.210.17:30090                 172.16.160.1:4847</div><div class="line">         cubic wscale:9,7 rto:202 rtt:1.667/0.011 ato:80 mss:1440 rcvmss:1460 advmss:1460 cwnd:10 bytes_acked:398583 bytes_received:613824362 segs_out:28630 segs_in:437621 data_segs_out:1495 data_segs_in:435792 send 69.1Mbps lastsnd:1179931 lastrcv:1179306 lastack:12149 pacing_rate 138.2Mbps delivery_rate 7.2Mbps app_limited busy:2520ms rcv_rtt:1.664 rcv_space:212976 minrtt:1.601</div><div class="line">ESTAB       86480  0        172.16.210.17:41482                 172.16.160.1:4847</div><div class="line">         cubic wscale:9,7 rto:215 rtt:14.945/1.83 ato:94 mss:1440 rcvmss:1460 advmss:1460 cwnd:10 bytes_acked:3899 bytes_received:93744 segs_out:73 segs_in:136 data_segs_out:20 data_segs_in:83 send 7.7Mbps lastsnd:449541 lastrcv:449145 lastack:19314 pacing_rate 15.4Mbps delivery_rate 964.2Kbps app_limited busy:296ms rcv_rtt:8561.27 rcv_space:14600 minrtt:11.948</div><div class="line">ESTAB       89136  0        172.16.210.17:40480                 172.16.160.1:4847</div><div class="line">         cubic wscale:9,7 rto:213 rtt:12.11/0.79 ato:196 mss:1440 rcvmss:1460 advmss:1460 cwnd:10 bytes_acked:2510 bytes_received:95652 segs_out:102 segs_in:168 data_segs_out:16 data_segs_in:81send 9.5Mbps lastsnd:1099067 lastrcv:1098659 lastack:13686 pacing_rate 19.0Mbps delivery_rate 1.0Mbps app_limited busy:199ms rcv_rtt:2438.63 rcv_space:14600 minrtt:11.178</div><div class="line">ESTAB       0      84288    172.16.210.17:3306                   10.100.7.26:51160</div><div class="line">         cubic wscale:7,7 rto:216 rtt:15.129/0.314 ato:40 mss:1448 rcvmss:976 advmss:1448 cwnd:157 ssthresh:157 bytes_acked:2954689465 bytes_received:1393 segs_out:2041403 segs_in:237797 data_segs_out:2041402 data_segs_in:8 send 120.2Mbps lastsnd:11 lastrcv:1103462 lastack:10 pacing_rate 144.2Mbps delivery_rate 31.3Mbps busy:1103503ms sndbuf_limited:3398ms(0.3%) unacked:24 retrans:0/7rcv_space:14600 notsent:49536 minrtt:9.551</div></pre></td></tr></table></figure>
<p>推荐 -m -i 一起查看状态，比如 rcv_space 表示buffer达到过的最大水位</p>
<blockquote>
<p><strong>rcv_space</strong> is the high water mark of the rate of the local application reading from the receive buffer during any RTT. This is used internally within the kernel to adjust sk_rcvbuf.</p>
</blockquote>
<h2 id="ss-查看拥塞窗口、RTO"><a href="#ss-查看拥塞窗口、RTO" class="headerlink" title="ss 查看拥塞窗口、RTO"></a>ss 查看拥塞窗口、RTO</h2><blockquote>
<p>//rto的定义，不让修改，每个ip的rt都不一样，必须通过rtt计算所得, HZ 一般是1秒</p>
<p>#define TCP_RTO_MAX     ((unsigned)(120*HZ))</p>
<p>#define TCP_RTO_MIN     ((unsigned)(HZ/5)) //在rt很小的环境中计算下来RTO基本等于TCP_RTO_MIN</p>
</blockquote>
<p>下面看到的rto和rtt单位都是毫秒，一般rto最小为200ms、最大为120秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#ss -itn |egrep &quot;cwnd|rto&quot;	</div><div class="line">ESTAB       0      165      [::ffff:192.168.0.174]:48074                [::ffff:192.168.0.173]:3306</div><div class="line">	cubic wscale:7,7 rto:201 rtt:0.24/0.112 ato:40 mss:1448 rcvmss:1448 advmss:1448 cwnd:10 bytes_acked:1910206449 bytes_received:8847784416 segs_out:11273005 segs_in:22997562 data_segs_out:9818729 data_segs_in:13341573 send 482.7Mbps lastsnd:1 lastrcv:1 pacing_rate 963.8Mbps delivery_rate 163.2Mbps app_limited busy:2676463ms retrans:0/183 rcv_rtt:1.001 rcv_space:35904 minrtt:0.135</div><div class="line"></div><div class="line">ESTAB       0      0        [::ffff:192.168.0.174]:48082                [::ffff:192.168.0.173]:3306</div><div class="line">	 cubic wscale:7,7 rto:201 rtt:0.262/0.112 ato:40 mss:1448 rcvmss:1448 advmss:1448 cwnd:10 bytes_acked:1852907381 bytes_received:8346503207 segs_out:10913962 segs_in:22169704 data_segs_out:9531411 data_segs_in:12796151 send 442.1Mbps lastsnd:2 lastack:2 pacing_rate 881.3Mbps delivery_rate 164.3Mbps app_limited busy:2736500ms retrans:0/260 rcv_rtt:1.042 rcv_space:31874 minrtt:0.133</div><div class="line">	 </div><div class="line">	 -----</div><div class="line">	 skmem:(r0,rb131072,t0,tb133632,f0,w0,o0,bl0,d0) cubic wscale:8,7 rto:233 rtt:32.489/2.99 ato:40 mss:1380 rcvmss:536 advmss:1460 cwnd:11 ssthresh:8 bytes_acked:99862366 bytes_received:2943 segs_out:78933 segs_in:23388 data_segs_out:78925 data_segs_in:81 send 3.7Mbps lastsnd:1735288 lastrcv:1735252 lastack:1735252 pacing_rate 4.5Mbps delivery_rate 2.9Mbps busy:370994ms retrans:0/6479 reordering:5 rcv_space:14600 minrtt:27.984</div></pre></td></tr></table></figure>
<h3 id="RTO计算算法"><a href="#RTO计算算法" class="headerlink" title="RTO计算算法"></a>RTO计算算法</h3><p>RTO的计算依赖于RTT值，或者说一系列RTT值。rto=f(rtt)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">1.1. 在没有任何rtt sample的时候，RTO &lt;- TCP_TIMEOUT_INIT (1s)</div><div class="line">   多次重传时同样适用指数回避算法(backoff)增加RTO  </div><div class="line"></div><div class="line">1.2. 获得第一个RTT sample后，</div><div class="line">    SRTT &lt;- RTT</div><div class="line">    RTTVAR &lt;- RTT/2</div><div class="line">    RTO &lt;- SRTT + max(G, K * RTTVAR)</div><div class="line">其中K=4, G表示timestamp的粒度(在CONFIG_HZ=1000时，粒度为1ms)</div><div class="line"></div><div class="line">1.3. 后续获得更多RTT sample后，</div><div class="line">    RTTVAR &lt;- (1 - beta) * RTTVAR + beta * |SRTT - R|</div><div class="line">    SRTT &lt;- (1 - alpha) * SRTT + alpha * R</div><div class="line">其中beta = 1/4, alpha = 1/8</div><div class="line"></div><div class="line">1.4. Whenever RTO is computed, if it is less than 1 second, then the</div><div class="line">   RTO SHOULD be rounder up to 1 second.</div><div class="line"></div><div class="line">1.5. A maximum value MAY be placed on RTO provided it is at least 60 seconds.</div></pre></td></tr></table></figure>
<p>RTTVAR表示的是平滑过的平均偏差，SRTT表示的平滑过的RTT。这两个值的具体含义会在后面介绍<br>具体实现的时候进一步的解释。<br>以上是计算一个初始RTO值的过程，当连续出现RTO超时后，<br>RTO值会用一个叫做指数回避的策略进行调整，下面来具体介绍。</p>
<h2 id="从系统cache中查看-tcp-metrics-item"><a href="#从系统cache中查看-tcp-metrics-item" class="headerlink" title="从系统cache中查看 tcp_metrics item"></a>从系统cache中查看 tcp_metrics item</h2><pre><code>$sudo ip tcp_metrics show | grep  100.118.58.7
100.118.58.7 age 1457674.290sec tw_ts 3195267888/5752641sec ago rtt 1000us rttvar 1000us ssthresh 361 cwnd 40 ----这两个值对传输性能很重要

192.168.1.100 age 1051050.859sec ssthresh 4 cwnd 2 rtt 4805us rttvar 4805us source 192.168.0.174 ---这条记录有问题，缓存的ssthresh 4 cwnd 2都太小，传输速度一定慢 

清除 tcp_metrics, sudo ip tcp_metrics flush all 
关闭 tcp_metrics 功能，net.ipv4.tcp_no_metrics_save = 1
sudo ip tcp_metrics delete 100.118.58.7
</code></pre><p>每个连接的ssthresh默认是个无穷大的值，但是内核会cache对端ip上次的ssthresh（大部分时候两个ip之间的拥塞窗口大小不会变），这样大概率到达ssthresh之后就基本拥塞了，然后进入cwnd的慢增长阶段。</p>
<h2 id="ss-过滤地址和端口号，类似tcpdump的用法"><a href="#ss-过滤地址和端口号，类似tcpdump的用法" class="headerlink" title="ss 过滤地址和端口号，类似tcpdump的用法"></a>ss 过滤地址和端口号，类似tcpdump的用法</h2><p>过滤目标端口是80的或者源端口是1723的连接，dst后面要跟空格然后加“：”：</p>
<pre><code># ss -ant dst :80 or src :1723 
State      Recv-Q Send-Q   Local Address:Port Peer Address:Port 
LISTEN     0      3        *:1723              *:*     
TIME-WAIT  0      0                                                     172.31.23.95:37269                                              111.161.68.235:80    
TIME-WAIT  0      0                                                     172.31.23.95:37263                                              111.161.68.235:80    
TIME-WAIT  0      0                                                     172.31.23.95:37267 
</code></pre><p>or：</p>
<pre><code>ss -ant dport = :80 or sport = :1723
</code></pre><p>地址筛选，目标地址是111.161.68.235的连接</p>
<pre><code>ss -ant dst 111.161.68.235
</code></pre><p>端口大小筛选，源端口大于1024的端口：</p>
<pre><code>ss sport gt 1024
</code></pre><p>How Do I Compare Local and/or Remote Port To A Number?<br>Use the following syntax:</p>
<pre><code>## Compares remote port to a number ##
ss dport OP PORT

## Compares local port to a number ##
sport OP PORT
</code></pre><p>Where OP can be one of the following:</p>
<pre><code>&lt;= or le : Less than or equal to port
&gt;= or ge : Greater than or equal to port
== or eq : Equal to port
!= or ne : Not equal to port
&lt; or gt : Less than to port
&gt; or lt : Greater than to port
Note: le, gt, eq, ne etc. are use in unix shell and are accepted as well.

###################################################################################
### Do not forget to escape special characters when typing them in command line ###
###################################################################################

ss  sport = :http
ss  dport = :http
ss  dport \&gt; :1024
ss  sport \&gt; :1024
ss sport \&lt; :32000
ss  sport eq :22
ss  dport != :22
ss  state connected sport = :http
ss \( sport = :http or sport = :https \)
ss -o state fin-wait-1 \( sport = :http or sport = :https \) dst 192.168.1/24
</code></pre><h2 id="ss-查看-timer-状态"><a href="#ss-查看-timer-状态" class="headerlink" title="ss 查看 timer 状态"></a>ss 查看 timer 状态</h2><p>ss -atonp</p>
<h2 id="按连接状态过滤"><a href="#按连接状态过滤" class="headerlink" title="按连接状态过滤"></a>按连接状态过滤</h2><p>Display All Established HTTP Connections</p>
<pre><code>ss -o state established &apos;( dport = :http or sport = :http )&apos;
</code></pre><p>List all the TCP sockets in state -FIN-WAIT-1 for our httpd to network 202.54.1/24 and look at their timers:<br>    ss -o state fin-wait-1 ‘( sport = :http or sport = :https )’ dst 202.54.1/24</p>
<p>Filter Sockets Using TCP States</p>
<pre><code>ss -4 state FILTER-NAME-HERE
</code></pre><p>Where FILTER-NAME-HERE can be any one of the following,</p>
<pre><code>established
syn-sent
syn-recv
fin-wait-1
fin-wait-2
time-wait
closed
close-wait
last-ack
listen
closing
all : All of the above states
connected : All the states except for listen and closed
synchronized : All the connected states except for syn-sent
bucket : Show states, which are maintained as minisockets, i.e. time-wait and syn-recv.
big : Opposite to bucket state.
</code></pre><h2 id="ss分析重传的包数量"><a href="#ss分析重传的包数量" class="headerlink" title="ss分析重传的包数量"></a>ss分析重传的包数量</h2><p>通过抓取ss命令，可以分析出来重传的包数量，然后将重传的流的数量和重传的包的数量按照对端IP:port的维度分段聚合，参考命令：</p>
<pre><code>ss -itn |grep -v &quot;Address:Port&quot; | xargs -L 1  | grep retrans | awk &apos;{gsub(&quot;retrans:.*/&quot;, &quot;&quot;,$21); print $5, $21}&apos; | awk &apos;{arr[$1]+=$2} END {for (i in arr) {print i,arr[i]}}&apos; | sort -rnk 2 
</code></pre><p>xargs <strong>-L 1</strong>  每一行处理一次，但是这个行如果是空格、tab结尾，那么会被认为是连续行，跟下一行合并</p>
<p>高版本Linux内核的话，可以用systemtap或者bcc来获取每个连接的重传包以及发生重传的阶段</p>
<h2 id="当前和最大全连接队列确认"><a href="#当前和最大全连接队列确认" class="headerlink" title="当前和最大全连接队列确认"></a>当前和最大全连接队列确认</h2><pre><code>$ss -lt
State      Recv-Q Send-Q Local Address:Port                 Peer Address:Port         
LISTEN     0      128    127.0.0.1:10248                       *:*                   
LISTEN     0      128           *:2376                        *:*                    
LISTEN     0      128    127.0.0.1:10249                       *:*                   
LISTEN     0      128           *:7337                        *:*                    
LISTEN     0      128           *:10250                       *:*                    
LISTEN     0      128    11.163.187.44:7946                        *:*               
LISTEN     0      128    127.0.0.1:55631                       *:*                   
LISTEN     0      128           *:10256                       *:*                    
LISTEN     0      10            *:6640                        *:*                    
LISTEN     0      128    127.0.0.1:vmware-fdm                  *:*                   
LISTEN     0      128    11.163.187.44:vmware-fdm                  *:*               
LISTEN     0      128           *:ssh                         *:*                    
LISTEN     0      10     127.0.0.1:15772                       *:*                   
LISTEN     0      10     127.0.0.1:15776                       *:*                   
LISTEN     0      10     127.0.0.1:19777                       *:*                   
LISTEN     0      10     11.163.187.44:15778                       *:*               
LISTEN     0      128           *:tr-rsrb-p2                  *:*
</code></pre><h2 id="ss-s"><a href="#ss-s" class="headerlink" title="ss -s"></a>ss -s</h2><p>统计所有连接的状态</p>
<h2 id="nstat"><a href="#nstat" class="headerlink" title="nstat"></a>nstat</h2><p>nstat -z -t 1 类似 netstat -s  (ss –info 展示rto、拥塞算法等更详细信息； netstat -ant -o 展示keepalive是否)</p>
<p>netstat<a href="http://perthcharles.github.io/2015/11/10/wiki-netstat-proc/" target="_blank" rel="external">参考</a></p>
<h2 id="knetstat"><a href="#knetstat" class="headerlink" title="knetstat"></a>knetstat</h2><p>最后给出的一个工具，knetstat（需要单独安装），也可以查看tcp的状态下的各种参数，需要单独安装</p>
<p>example(3306是本地server，4192是后端MySQL）：</p>
<pre><code>Recv-Q Send-Q Local Address           Foreign Address         Stat Diag Options
 0      0 0.0.0.0:3306            0.0.0.0:*               LSTN      SO_REUSEADDR=1,SO_REUSEPORT=0,SO_KEEPALIVE=0,TCP_NODELAY=0,TCP_FASTOPEN=0,TCP_DEFER_ACCEPT=0
 0      0 0.0.0.0:3406            0.0.0.0:*               LSTN      SO_REUSEADDR=1,SO_REUSEPORT=0,SO_KEEPALIVE=0,TCP_NODELAY=0,TCP_FASTOPEN=0,TCP_DEFER_ACCEPT=0
 0      0 127.0.0.1:8182          0.0.0.0:*               LSTN      SO_REUSEADDR=1,SO_REUSEPORT=0,SO_KEEPALIVE=0,TCP_NODELAY=0,TCP_FASTOPEN=0,TCP_DEFER_ACCEPT=0
 0      0 10.0.186.73:8182        0.0.0.0:*               LSTN      SO_REUSEADDR=1,SO_REUSEPORT=0,SO_KEEPALIVE=0,TCP_NODELAY=0,TCP_FASTOPEN=0,TCP_DEFER_ACCEPT=0
 0      0 0.0.0.0:22              0.0.0.0:*               LSTN      SO_REUSEADDR=1,SO_REUSEPORT=0,SO_KEEPALIVE=0,TCP_NODELAY=0,TCP_FASTOPEN=0,TCP_DEFER_ACCEPT=0
 0      0 0.0.0.0:8188            0.0.0.0:*               LSTN      SO_REUSEADDR=1,SO_REUSEPORT=0,SO_KEEPALIVE=0,TCP_NODELAY=0,TCP_FASTOPEN=0,TCP_DEFER_ACCEPT=0
 0      0 127.0.0.1:15778         0.0.0.0:*               LSTN      SO_REUSEADDR=1,SO_REUSEPORT=0,SO_KEEPALIVE=0,TCP_NODELAY=0,TCP_FASTOPEN=0,TCP_DEFER_ACCEPT=0 
 0    138 10.0.186.73:51756       10.0.160.1:4192         ESTB &gt;#   SO_REUSEADDR=0,SO_REUSEPORT=0,SO_KEEPALIVE=1,TCP_NODELAY=1,TCP_DEFER_ACCEPT=0
 0      0 10.0.186.73:3306        10.0.186.70:37428       ESTB      SO_REUSEADDR=1,SO_REUSEPORT=0,SO_KEEPALIVE=1,SO_RCVBUF=32768,SO_SNDBUF=65536,TCP_NODELAY=1,TCP_DEFER_ACCEPT=0
 0    138 10.0.186.73:51476       10.0.160.1:4192         ESTB &gt;#   SO_REUSEADDR=0,SO_REUSEPORT=0,SO_KEEPALIVE=1,TCP_NODELAY=1,TCP_DEFER_ACCEPT=0
 0      0 10.0.186.73:3306        10.0.186.70:37304       ESTB      SO_REUSEADDR=1,SO_REUSEPORT=0,SO_KEEPALIVE=1,SO_RCVBUF=32768,SO_SNDBUF=65536,TCP_NODELAY=1,TCP_DEFER_ACCEPT=0
 0      0 10.0.186.73:51842       10.0.160.1:4192         ESTB      SO_REUSEADDR=0,SO_REUSEPORT=0,SO_KEEPALIVE=1,TCP_NODELAY=1,TCP_DEFER_ACCEPT=0
44      0 10.0.186.73:3306        10.0.186.70:36238       ESTB      SO_REUSEADDR=1,SO_REUSEPORT=0,SO_KEEPALIVE=1,SO_RCVBUF=32768,SO_SNDBUF=65536,TCP_NODELAY=1,TCP_DEFER_ACCEPT=0
44      0 10.0.186.73:3306        10.0.186.70:36160       ESTB      SO_REUSEADDR=1,SO_REUSEPORT=0,SO_KEEPALIVE=1,SO_RCVBUF=32768,SO_SNDBUF=65536,TCP_NODELAY=1,TCP_DEFER_ACCEPT=0
0      0 10.0.186.73:19030       10.0.171.188:8000       TIMW
</code></pre><p>3306对应的client上：</p>
<pre><code>Recv-Q Send-Q Local Address           Foreign Address         Stat Diag Options
 0     44 10.0.186.70:42428       10.0.186.73:3306        ESTB &gt;#   SO_REUSEADDR=0,SO_REUSEPORT=0,SO_KEEPALIVE=1,SO_RCVTIMEO=31536000000ms,SO_SNDTIMEO=31536000000ms,TCP_NODELAY=1,TCP_DEFER_ACCEPT=0
 0     44 10.0.186.70:42298       10.0.186.73:3306        ESTB &gt;#   SO_REUSEADDR=0,SO_REUSEPORT=0,SO_KEEPALIVE=1,SO_RCVTIMEO=31536000000ms,SO_SNDTIMEO=31536000000ms,TCP_NODELAY=1,TCP_DEFER_ACCEPT=0
 0     44 10.0.186.70:42296       10.0.186.73:3306        ESTB &gt;#   SO_REUSEADDR=0,SO_REUSEPORT=0,SO_KEEPALIVE=1,SO_RCVTIMEO=31536000000ms,SO_SNDTIMEO=31536000000ms,TCP_NODELAY=1,TCP_DEFER_ACCEPT=0
 0     44 10.0.186.70:42322       10.0.186.73:3306        ESTB &gt;#   SO_REUSEADDR=0,SO_REUSEPORT=0,SO_KEEPALIVE=1,SO_RCVTIMEO=31536000000ms,SO_SNDTIMEO=31536000000ms,TCP_NODELAY=1,TCP_DEFER_ACCEPT=0
</code></pre><p>Diag列的说明<br>    Indicator        Meaning</p>
<pre><code>&gt;|             The sender window (i.e. the window advertised by the remote endpoint) is 0. No data can be sent to the peer.
  &gt;|&lt;             The receiver window (i.e. the window advertised by the local endpoint) is 0. No data can be received from the peer.
&gt;
&gt;#             There are unacknowledged packets and the last ACK was received more than one second ago. This may be an indication that there are network problems or that the peer crashed.
</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cyberciti.biz/tips/linux-investigate-sockets-network-connections.html" target="_blank" rel="external">https://www.cyberciti.biz/tips/linux-investigate-sockets-network-connections.html</a></p>
<p><a href="http://perthcharles.github.io/2015/11/10/wiki-netstat-proc/" target="_blank" rel="external">http://perthcharles.github.io/2015/11/10/wiki-netstat-proc/</a></p>
<p>源代码：<a href="https://github.com/sivasankariit/iproute2/blob/master/misc/ss.c" target="_blank" rel="external">https://github.com/sivasankariit/iproute2/blob/master/misc/ss.c</a></p>
<p><a href="https://github.com/veithen/knetstat/tree/master" target="_blank" rel="external">https://github.com/veithen/knetstat/tree/master</a></p>
<p><a href="https://access.redhat.com/discussions/782343" target="_blank" rel="external">https://access.redhat.com/discussions/782343</a></p>
<p><a href="https://perthcharles.github.io/2015/09/06/wiki-rtt-estimator/" target="_blank" rel="external">RTO的计算方法(基于RFC6298和Linux 3.10)</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2016/08/24/Linux tc qdisc的使用案例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weibo @plantegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/24/Linux tc qdisc的使用案例/" itemprop="url">Linux tc qdisc的使用案例</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-24T17:30:03+08:00">
                2016-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Linux-tc-qdisc的使用案例"><a href="#Linux-tc-qdisc的使用案例" class="headerlink" title="Linux tc qdisc的使用案例"></a>Linux tc qdisc的使用案例</h1><p>在linux下通过tc qdisc 很容易对rt延时、丢包、带宽进行控制，这样的话方便重现各种网络问题</p>
<h2 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1. give packets from eth0 a delay of 2ms</div><div class="line"><span class="meta">bash$</span> tc qdisc add dev eth0 root netem delay 2ms</div><div class="line"> </div><div class="line">2.change the delay to 300ms</div><div class="line"><span class="meta">bash$</span> tc qdisc change dev eth0 root netem delay 3ms</div><div class="line"></div><div class="line">3.display eth0 delay setting</div><div class="line"><span class="meta">bash$</span> tc qdisc show dev eth0</div><div class="line"> </div><div class="line">4.stop the delay</div><div class="line"><span class="meta">bash$</span> tc qdisc del dev eth0 root</div><div class="line"><span class="meta"></span></div><div class="line">#corrupt</div><div class="line">The following rule corrupts 5% of the packets by introducing single bit error at a random offset in the packet:</div><div class="line">tc qdisc change dev eth0 root netem corrupt 5%</div></pre></td></tr></table></figure>
<h2 id="模拟网络丢包"><a href="#模拟网络丢包" class="headerlink" title="模拟网络丢包"></a>模拟网络丢包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc add dev eth0 root netem loss 1%</div></pre></td></tr></table></figure>
<p>指定ip 172.31.65.30延时17ms， 测试发现181和183这两句命令顺序无所谓。恢复正常：179行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">179  tc qdisc del dev eth0 root</div><div class="line">180  tc qdisc add dev eth0 root handle 1: prio</div><div class="line">181  tc filter add dev eth0 parent 1:0 protocol ip pref 55 handle ::55 u32 match ip dst 172.31.65.30 flowid 2:1</div><div class="line">182  tc qdisc ls</div><div class="line">183  tc qdisc add dev eth0 parent 1:1 handle 2: netem delay 17ms</div></pre></td></tr></table></figure>
<h2 id="指定ip和端口延时"><a href="#指定ip和端口延时" class="headerlink" title="指定ip和端口延时"></a>指定ip和端口延时</h2><p>指定 eth0 网卡，来源 ip 是 10.0.1.1，目的端口是 3306 的访问延迟 20ms，上下浮动 2ms </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 指定 eth0 网卡，来源 ip 是 10.0.1.1，目的端口是 3306 的访问延迟 20ms，上下浮动 2ms</div><div class="line">tc qdisc add dev eth0 root handle 1: prio bands 4</div><div class="line">tc qdisc add dev eth0 parent 1:4 handle 40: netem delay 20ms 2ms</div><div class="line">tc filter add dev eth0 parent 1: protocol ip prio 4 basic match &quot;cmp(u16 at 2 layer transport eq 3306)</div><div class="line">                            and cmp(u8 at 16 layer network eq 10)</div><div class="line">                            and cmp(u8 at 17 layer network eq 0)</div><div class="line">                            and cmp(u8 at 18 layer network eq 1)</div><div class="line">                            and cmp(u8 at 19 layer network eq 1)&quot; flowid 1:4</div><div class="line">                            </div><div class="line"># 删除过滤</div><div class="line">sudo tc filter del dev eth0 parent 1: prio 4 basic</div><div class="line">sudo tc qdisc  del dev eth0 root</div></pre></td></tr></table></figure>
<p>0 layer 代表 sport<br>2 layer 代表 dport</p>
<h2 id="指定端口34001上，延时5ms"><a href="#指定端口34001上，延时5ms" class="headerlink" title="指定端口34001上，延时5ms"></a>指定端口34001上，延时5ms</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tc qdisc add dev eth0 root handle 1: prio</div><div class="line">tc qdisc add dev eth0 parent 1:3 handle 30: netem delay 5ms</div><div class="line">tc filter add dev eth0 protocol ip parent 1:0 u32 match ip sport 34001 0xffff flowid 1:3</div></pre></td></tr></table></figure>
<h2 id="控制eth0网卡的带宽、延时、乱序、丢包"><a href="#控制eth0网卡的带宽、延时、乱序、丢包" class="headerlink" title="控制eth0网卡的带宽、延时、乱序、丢包"></a>控制eth0网卡的带宽、延时、乱序、丢包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">sudo tc qdisc add dev bond0 root handle 1: netem delay 10ms reorder 25% 50% loss 0.2%</div><div class="line">sudo tc qdisc add dev bond0 parent 1: handle 2: tbf rate 1mbit burst 32kbit latency 10ms</div><div class="line"></div><div class="line">/sbin/tc qdisc add dev eth0 root tbf rate 500kbit latency 50ms burst 15kb</div><div class="line"></div><div class="line">// 同时模拟20Mbps带宽，50msRTT和0.1%丢包率  </div><div class="line"><span class="meta">#</span> tc qdisc add dev eth5 root handle 1:0 tbf rate 20mbit burst 10kb limit 300000  </div><div class="line"><span class="meta">#</span> tc qdisc add dev eth5 parent 1:0 handle 10:0 netem delay 50ms loss 0.1 limit 300000 </div><div class="line"></div><div class="line">tc qdisc change dev eth0 root netem reorder 50% gap 3 delay 1ms</div><div class="line">tc qdisc change dev eth0 root netem delay 1ms reorder 15%</div><div class="line"></div><div class="line"></div><div class="line">//在eth0上设置一个tbf队列，网络带宽为200kbit，延迟10ms以内，超出的包会被drop掉，缓冲区为1540个字节</div><div class="line">sudo /sbin/tc qdisc add dev eth0 root tbf rate 200kbit latency 10ms burst 15kb</div><div class="line">sudo /sbin/tc qdisc ls dev eth0</div></pre></td></tr></table></figure>
<p>在eth0上设置一个tbf队列，网络带宽为200kbit，延迟10ms以内，超出的包会被drop掉，缓冲区为1540个字节<br>rate表示令牌的产生速率, <em>sustained maximum rate</em><br>latency表示数据包在队列中的最长等待时间, <em>packets with higher latency get dropped</em><br>burst参数表示  maximum allowed burst：<br>  burst means the maximum amount of bytes that tokens can be available for instantaneously.<br>  如果数据包的到达速率与令牌的产生速率一致，即200kbit，则数据不会排队，令牌也不会剩余<br>  如果数据包的到达速率小于令牌的产生速率，则令牌会有一定的剩余。<br>  如果后续某一会数据包的到达速率超过了令牌的产生速率，则可以一次性的消耗一定量的令牌。<br>  burst就是用于限制这“一次性”消耗的令牌的数量的，以字节数为单位。</p>
<p>tbf: <em>use</em> the <em>token buffer filter to manipulate traffic rates</em></p>
<p>限制10MB，排队等待超过100ms就触发丢包，只限制了出去的流量，没有限制进来的流量:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tc qdisc ls dev eth0 // 查看eth0上的队列规则  </div><div class="line">sudo tc qdisc add dev eth0 root tbf rate 80mbit burst 1mbit latency 100ms </div><div class="line"></div><div class="line">//限制80MB</div><div class="line">sudo tc qdisc add dev eth0 root tbf rate 80mbps burst 1mbps latency 100ms</div></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//Server: 4 Mbit 50 ms</div><div class="line">tc qdisc add dev eth0 handle 1: root htb default 11</div><div class="line">tc class add dev eth0 parent 1: classid 1:1 htb rate 1000Mbps</div><div class="line">tc class add dev eth0 parent 1:1 classid 1:11 htb rate 4Mbit</div><div class="line">tc qdisc add dev eth0 parent 1:11 handle 10: netem delay 50ms</div><div class="line"></div><div class="line">//Client: 512 kbit 50 ms</div><div class="line">tc qdisc add dev vmnet1 handle 1: root htb default 11</div><div class="line">tc class add dev vmnet1 parent 1: classid 1:1 htb rate 1000Mbps</div><div class="line">tc class add dev vmnet1 parent 1:1 classid 1:11 htb rate 512kbit</div><div class="line">tc qdisc add dev vmnet1 parent 1:11 handle 10: netem delay 50ms</div></pre></td></tr></table></figure>
<h2 id="qdisc的类别"><a href="#qdisc的类别" class="headerlink" title="qdisc的类别"></a><a href="https://cloud.tencent.com/developer/article/1409664" target="_blank" rel="external">qdisc的类别</a></h2><p>QDisc(排队规则)是queueing discipline的简写，它是理解流量控制(traffic control)的基础。无论何时，内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的qdisc(排队规则)把数据包加入队列。然后，内核会尽可能多地从qdisc里面取出数据包，把它们交给网络适配器驱动模块。最简单的QDisc是pfifo它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。不过，它会保存网络接口一时无法处理的数据包。</p>
<ul>
<li><p>CLASSLESS QDisc(不可分类QDisc)</p>
<ul>
<li>[p|b]fifo： 使用最简单的qdisc，纯粹的先进先出。只有一个参数：limit，用来设置队列的长度,pfifo是以数据包的个数为单位；bfifo是以字节数为单位。</li>
<li>pfifo_fast： 在编译内核时，如果打开了高级路由器(Advanced Router)编译选项，pfifo_fast就是系统的标准QDISC。它的队列包括三个波段(band)。在每个波段里面，使用先进先出规则。而三个波段(band)的优先级也不相同，band 0的优先级最高，band 2的最低。如果band0里面有数据包，系统就不会处理band 1里面的数据包，band 1和band 2之间也是一样。数据包是按照服务类型(Type of Service,TOS)被分配多三个波段(band)里面的。</li>
<li>red： red是Random Early Detection(随机早期探测)的简写。如果使用这种QDISC，当带宽的占用接近于规定的带宽时，系统会随机地丢弃一些数据包。它非常适合高带宽应用。</li>
<li>sfq： sfq是Stochastic Fairness Queueing的简写。它按照会话(session–对应于每个TCP连接或者UDP流)为流量进行排序，然后循环发送每个会话的数据包。</li>
<li>tbf： tbf是Token Bucket Filter的简写，适合于把流速降低到某个值。</li>
</ul>
</li>
</ul>
<p>一个网络接口上如果没有设置QDisc，pfifo_fast就作为缺省的QDisc。</p>
<p>CLASSFUL QDISC(分类QDisc)，可分类的qdisc包括： </p>
<ul>
<li>CBQ： CBQ是Class Based Queueing(基于类别排队)的缩写。它实现了一个丰富的连接共享类别结构，既有限制(shaping)带宽的能力，也具有带宽优先级管理的能力。带宽限制是通过计算连接的空闲时间完成的。空闲时间的计算标准是数据包离队事件的频率和下层连接(数据链路层)的带宽。</li>
<li>HTB： HTB是Hierarchy Token Bucket的缩写。通过在实践基础上的改进，它实现了一个丰富的连接共享类别体系。使用HTB可以很容易地保证每个类别的带宽，它也允许特定的类可以突破带宽上限，占用别的类的带宽。HTB可以通过TBF(Token Bucket Filter)实现带宽限制，也能够划分类别的优先级。</li>
<li>PRIO： PRIO QDisc不能限制带宽，因为属于不同类别的数据包是顺序离队的。使用PRIO QDisc可以很容易对流量进行优先级管理，只有属于高优先级类别的数据包全部发送完毕，才会发送属于低优先级类别的数据包。为了方便管理，需要使用iptables或者ipchains处理数据包的服务类型(Type Of Service,ToS)。</li>
</ul>
<h3 id="htb分类-qdisc"><a href="#htb分类-qdisc" class="headerlink" title="htb分类 qdisc"></a>htb分类 qdisc</h3><p>tbf能对流量无差别控制，htb可以进一步进行更精细的控制</p>
<h4 id="针对IP、端口限速案例"><a href="#针对IP、端口限速案例" class="headerlink" title="针对IP、端口限速案例"></a>针对IP、端口限速案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span>cat qdisc_bw.sh</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span>针对不同的ip进行限速</div><div class="line"><span class="meta"></span></div><div class="line">#清空原有规则</div><div class="line">tc qdisc del dev eth0 root</div><div class="line"><span class="meta"></span></div><div class="line">#创建根序列</div><div class="line">tc qdisc add dev eth0 root handle 1: htb default 1</div><div class="line"><span class="meta"></span></div><div class="line">#创建一个主分类绑定所有带宽资源（60M）</div><div class="line">tc class add dev eth0 parent 1:0 classid 1:1 htb rate 60Mbps burst 15k</div><div class="line"><span class="meta">#</span>到这里可以使用了，整机速度限制到了60M</div><div class="line"><span class="meta"></span></div><div class="line">#创建子分类，ceil表示最大带宽</div><div class="line">tc class add dev eth0 parent 1:1 classid 1:10 htb rate 2Mbps ceil 1Mbps burst 15k</div><div class="line">tc class add dev eth0 parent 1:1 classid 1:20 htb rate 20Mbps ceil 30Mbps burst 15k</div><div class="line"><span class="meta"></span></div><div class="line">#为了避免一个会话永占带宽,添加随即公平队列sfq.</div><div class="line"><span class="meta">#</span>perturb：是多少秒后重新配置一次散列算法，默认为10秒</div><div class="line"><span class="meta">#</span>sfq,他可以防止一个段内的一个ip占用整个带宽</div><div class="line">tc qdisc add dev eth0 parent 1:10 handle 10: sfq perturb 10</div><div class="line">tc qdisc add dev eth0 parent 1:20 handle 20: sfq perturb 10</div><div class="line"><span class="meta"></span></div><div class="line">#创建过滤器</div><div class="line"><span class="meta">#</span>对所有ip限速到1Mbps</div><div class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 2 u32 match ip dst 0.0.0.0/0 flowid 1:10</div><div class="line"><span class="meta">#</span>对10.0.186.140限速在30Mbps</div><div class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip dst 10.0.186.140 flowid 1:20</div><div class="line"><span class="meta"></span></div><div class="line">#对端口进行filter限流</div><div class="line"><span class="meta">#</span>tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip sport 22 flowid 1:10</div><div class="line"><span class="meta"></span></div><div class="line">#查看以上规则</div><div class="line">sudo tc class show dev eth0</div><div class="line">sudo tc filter show dev eth0</div></pre></td></tr></table></figure>
<p>限流100MB后的实际监控效果</p>
<p><img src="/images/951413iMgBlog/image-20211031205539407.png" alt="image-20211031205539407"></p>
<h2 id="docker-中使用-tc"><a href="#docker-中使用-tc" class="headerlink" title="docker 中使用 tc"></a>docker 中使用 tc</h2><p>docker里无法使用的bug 可以参考 <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1152231，解决方法就是升级tc版本，tc" target="_blank" rel="external">https://bugzilla.redhat.com/show_bug.cgi?id=1152231，解决方法就是升级tc版本，tc</a> qdisc add 时加上direct_qlen参数</p>
<h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>故障注入的docker: 10.1.1.149</p>
<p>10.1.1.149上会模拟各种网络故障，但是中控机到该docker的连接需要不受影响</p>
<p>DEVICE_NAME=eth0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"># 根规则，direct_qlen 1000必须加，否则在docker的虚拟网络跑不了</div><div class="line">tc qdisc add dev $&#123;DEVICE_NAME&#125; root handle 1: htb  default 1024 direct_qlen 1000</div><div class="line"></div><div class="line"></div><div class="line"># 建立两个类继承root</div><div class="line">tc class add dev $&#123;DEVICE_NAME&#125; parent 1:0 classid 1:1 htb rate 10000mbit</div><div class="line">tc class add dev $&#123;DEVICE_NAME&#125; parent 1:0 classid 1:2 htb rate 10000mbit</div><div class="line"></div><div class="line"></div><div class="line">#新版本的tc在filter设置完后，所有网络都会断，类似黑名单，需要加qdisc才能恢复, 所以先让两个通道都能跑</div><div class="line"># 队列采用公平的调度算法，保证网络通畅，perturb参数是每隔10秒换一次hash，进一步保障平均</div><div class="line">tc qdisc add dev $&#123;DEVICE_NAME&#125; parent 1:1 sfq perturb 10</div><div class="line">tc qdisc add dev $&#123;DEVICE_NAME&#125; parent 1:2 sfq perturb 10</div><div class="line"></div><div class="line"></div><div class="line"># 加过滤规则</div><div class="line">#1.队列1是和跳板机交互的网络，需要保持通畅</div><div class="line">tc filter add dev $&#123;DEVICE_NAME&#125; protocol ip parent 1: prio 10 u32 match ip dst 11.136.106.200/32 flowid 1:1</div><div class="line"></div><div class="line"></div><div class="line">#2.其他所有主机走队列2，实现网络模拟</div><div class="line">tc filter add dev $&#123;DEVICE_NAME&#125; protocol ip parent 1: prio 10 u32 match ip dst 0.0.0.0/0 flowid 1:2</div><div class="line"></div><div class="line">#队列2 开始网络模拟</div><div class="line">#该命令将$&#123;DEVICE_NAME&#125;网卡的耗时随机delay 100ms，延迟的尖刺在标准值的正负30ms, 最后的百分比数字是尖刺的相关系数</div><div class="line"></div><div class="line"># 这边用replace是因为之前已经用add加过规则了</div><div class="line">tc qdisc replace dev $&#123;DEVICE_NAME&#125; parent 1:2 netem delay 100ms 30ms 25%</div><div class="line"></div><div class="line"></div><div class="line">#该命令将 $&#123;DEVICE_NAME&#125; 网卡的传输设置为随机丢掉10%的数据包, 成功率为50%</div><div class="line">tc qdisc replace dev $&#123;DEVICE_NAME&#125; parent 1:2 netem loss 10% 50%</div><div class="line"></div><div class="line"></div><div class="line">#该命令将 $&#123;DEVICE_NAME&#125; 网卡的传输设置为随机产生10%的重复数据包。</div><div class="line">tc qdisc replace dev $&#123;DEVICE_NAME&#125; parent 1:2 netem duplicate 10%</div><div class="line"></div><div class="line"></div><div class="line">#该命令将 $&#123;DEVICE_NAME&#125; 网卡的传输设置为:有25%的数据包会被立即发送,其他的延迟10ms,相关性是10%,产生乱序</div><div class="line">tc qdisc replace dev $&#123;DEVICE_NAME&#125; parent 1:2 netem delay 10ms reorder 25% 10% </div><div class="line"></div><div class="line"></div><div class="line">#该命令将 $&#123;DEVICE_NAME&#125; 网卡的传输设置为随机产生9%的损坏的数据包</div><div class="line">tc qdisc replace dev $&#123;DEVICE_NAME&#125; parent 1:2 netem corrupt 9%</div></pre></td></tr></table></figure>
<p>恢复网络</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#让网络恢复正常</div><div class="line">tc qdisc replace dev $&#123;DEVICE_NAME&#125; parent 1:2 sfq perturb 10</div><div class="line"></div><div class="line"># =================== 查看规则 ======================</div><div class="line">tc filter show dev $&#123;DEVICE_NAME&#125;</div><div class="line">tc class show dev $&#123;DEVICE_NAME&#125;</div><div class="line">tc qdisc show dev $&#123;DEVICE_NAME&#125;</div><div class="line"></div><div class="line">#====================== 清理 ======================</div><div class="line">tc filter delete dev $&#123;DEVICE_NAME&#125; parent 1:0 protocol ip pref 10</div><div class="line">tc qdisc del dev $&#123;DEVICE_NAME&#125; parent 1:2 netem</div><div class="line">tc class del dev $&#123;DEVICE_NAME&#125; parent 1:0 classid 1:2</div><div class="line">tc class del dev $&#123;DEVICE_NAME&#125; parent 1:0 classid 1:1</div><div class="line">tc qdisc del dev $&#123;DEVICE_NAME&#125; root handle 1</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://netbeez.net/blog/how-to-use-the-linux-traffic-control/" target="_blank" rel="external">https://netbeez.net/blog/how-to-use-the-linux-traffic-control/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2016/03/24/ansible 使用手册/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weibo @plantegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/24/ansible 使用手册/" itemprop="url">ansible 手册</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-24T17:30:03+08:00">
                2016-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ansible/" itemprop="url" rel="index">
                    <span itemprop="name">Ansible</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ansible-手册"><a href="#ansible-手册" class="headerlink" title="ansible 手册"></a>ansible 手册</h1><h2 id="获取模块信息"><a href="#获取模块信息" class="headerlink" title="获取模块信息"></a>获取模块信息</h2><p>-<br>获取所有模块信息，100多个</p>
<ul>
<li>ansible-doc -l</li>
</ul>
<p>获取每个模块的具体信息 </p>
<ul>
<li><p>ansible-doc<br>example：ansible-doc ping</p>
<p>   PING</p>
<p>   A trivial test module, this module always returns <code>pong&#39; on
   successful contact. It does not make sense in playbooks, but it is
   useful from</code>/usr/bin/udp’</p>
<p> EXAMPLES:<br> Test ‘webservers’ status</p>
<p> udp webservers -m ping</p>
</li>
</ul>
<h2 id="嵌套执行命令roles"><a href="#嵌套执行命令roles" class="headerlink" title="嵌套执行命令roles"></a>嵌套执行命令roles</h2><pre><code>- name: create jdk home
  file: path={{ remote_jdk_home }} state=directory mode=0755

- name: xxxxxxxxx
  include: ../../init/tasks/main.yml
</code></pre><h2 id="defaults-中变量定义"><a href="#defaults-中变量定义" class="headerlink" title="defaults 中变量定义"></a>defaults 中变量定义</h2><pre><code>1：加双引号；2：变量名和变量之间，有空格；
diamond_db_key: &quot;{{ diamond_db_ip }}_{{ diamond_db_name }}_dbkey&quot;
manager_user1: &quot;{{ manager_user_name }}&quot;
</code></pre><h1 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h1><p>相同的tasks在不同的环境下面执行，通过tag来进行表面，如下图：</p>
<pre><code>  useage: 
    udp-playbook setup.yml -v -kK -i hosts.ini --tags &quot;ta&quot;

- name: 1
  authorized_key: user={{ ansible_ssh_user }}  key=&quot;{{ lookup('file', '~/.ssh/id_rsa.pub') }}&quot;  state=present
  tags: ta

- name: 2
  group: name={{ remote_user }}
  tags: always

- name: 3
  file: path={{ remote_home }} owner={{ remote_user }} group={{ remote_user }} state=directory recurse=yes mode=0755
  tags: tb
</code></pre><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>ansible 中 scp scp: ambiguous target 错误还是因为ssh 增加了 -t 参数, scp不支持 -t 参数</p>
<h2 id="disable-python-warning"><a href="#disable-python-warning" class="headerlink" title="disable python warning"></a><a href="https://docs.ansible.com/ansible/latest/reference_appendices/interpreter_discovery.html" target="_blank" rel="external">disable python warning</a></h2><p>To control the discovery behavior:</p>
<ul>
<li>for individual hosts and groups, use the <code>ansible_python_interpreter</code> inventory variable</li>
<li>globally, use the <code>interpreter_python</code> key in the <code>[defaults]</code> section of <code>ansible.cfg</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[defaults]</div><div class="line">interpreter_python=auto_silent</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2016/03/24/ansible 常见问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weibo @plantegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/24/ansible 常见问题/" itemprop="url">ansible 常见问题</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-24T17:30:03+08:00">
                2016-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ansible/" itemprop="url" rel="index">
                    <span itemprop="name">Ansible</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ansible-常见问题"><a href="#ansible-常见问题" class="headerlink" title="ansible 常见问题"></a>ansible 常见问题</h1><h2 id="获取模块信息"><a href="#获取模块信息" class="headerlink" title="获取模块信息"></a>获取模块信息</h2><p>-<br>获取所有模块信息，100多个</p>
<ul>
<li>ansible-doc -l</li>
</ul>
<p>获取每个模块的具体信息 </p>
<ul>
<li><p>ansible-doc<br>example：ansible-doc ping</p>
<p>   PING</p>
<p>   A trivial test module, this module always returns <code>pong&#39; on
   successful contact. It does not make sense in playbooks, but it is
   useful from</code>/usr/bin/udp’</p>
<p> EXAMPLES:<br> Test ‘webservers’ status</p>
<p> udp webservers -m ping</p>
</li>
</ul>
<h2 id="嵌套执行命令roles"><a href="#嵌套执行命令roles" class="headerlink" title="嵌套执行命令roles"></a>嵌套执行命令roles</h2><pre><code>- name: create jdk home
  file: path={{ remote_jdk_home }} state=directory mode=0755

- name: xxxxxxxxx
  include: ../../init/tasks/main.yml
</code></pre><h2 id="defaults-中变量定义"><a href="#defaults-中变量定义" class="headerlink" title="defaults 中变量定义"></a>defaults 中变量定义</h2><pre><code>1：加双引号；2：变量名和变量之间，有空格；
diamond_db_key: &quot;{{ diamond_db_ip }}_{{ diamond_db_name }}_dbkey&quot;
manager_user1: &quot;{{ manager_user_name }}&quot;
</code></pre><h1 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h1><p>相同的tasks在不同的环境下面执行，通过tag来进行表面，如下图：</p>
<pre><code>  useage: 
    udp-playbook setup.yml -v -kK -i hosts.ini --tags &quot;ta&quot;

- name: 1
  authorized_key: user={{ ansible_ssh_user }}  key=&quot;{{ lookup('file', '~/.ssh/id_rsa.pub') }}&quot;  state=present
  tags: ta

- name: 2
  group: name={{ remote_user }}
  tags: always

- name: 3
  file: path={{ remote_home }} owner={{ remote_user }} group={{ remote_user }} state=directory recurse=yes mode=0755
  tags: tb
</code></pre><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>ansible 中 scp scp: ambiguous target 错误还是因为ssh 增加了 -t 参数, scp不支持 -t 参数</p>
<h2 id="disable-python-warning"><a href="#disable-python-warning" class="headerlink" title="disable python warning"></a><a href="https://docs.ansible.com/ansible/latest/reference_appendices/interpreter_discovery.html" target="_blank" rel="external">disable python warning</a></h2><p>To control the discovery behavior:</p>
<ul>
<li>for individual hosts and groups, use the <code>ansible_python_interpreter</code> inventory variable</li>
<li>globally, use the <code>interpreter_python</code> key in the <code>[defaults]</code> section of <code>ansible.cfg</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[defaults]</div><div class="line">interpreter_python=auto_silent</div></pre></td></tr></table></figure>
<h3 id="其它常见错误"><a href="#其它常见错误" class="headerlink" title="其它常见错误"></a>其它常见错误</h3><table>
<thead>
<tr>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>性能</td>
<td>ansible现在并发执行的任务好像还不够，执行批量传大文件的任务等的比较久 — 用 synchronize  并将 fork 默认的5改大</td>
</tr>
<tr>
<td>sudoers</td>
<td>尝试解决ansible不能执行的问题，搜索各种英文文档，有人说版本的原因，有人反馈是脚本错误，最终无解。 继续在本地进行测试，发现使用原始的ansible命令可以执行ls，但是sudo ls时会提示 sudo need tty 之类的报错。 定位这个错误是因为在/etc/sudoers文件中设置了  Defaults requiretty，修改为 #Defaults requiretty，重试发现问题解决。 手工修改所有机器的配置文件，问题解决。{“msg”: “ssh connection closed waiting for a privilege escalation password prompt”}—实际在部分机器上执行ansible命令时仍然有：sudo: no tty present and no askpass program specified  可以给ssh 增加-t/-tt参数来强制分配一个tty</td>
</tr>
<tr>
<td>failed to transfer file to  xxx</td>
<td>远端机器磁盘已经满,查看df -h，特别是/tmp</td>
</tr>
<tr>
<td>requires a json module, none found</td>
<td>问题已经通过nginx进行解决部署,安装ansible的时候，在目标机器上面安装 python-simplejson 通过如下命令：yum install python-simplejson -y</td>
</tr>
<tr>
<td>openssh升级后无法登录报错</td>
<td>sshrpm 升级后会修改/etc/pam.d/sshd 文件。需要升级前备份此文件最后还原即可登录。</td>
</tr>
<tr>
<td>安装EagleEye出现的问题</td>
<td>1.hadoop name -format 这个需要输入Y/N；2.ssh-key没搞定；3.我们原来可以for循环的地方，古谦脚本只能1条1条的加</td>
</tr>
<tr>
<td>使用lineinfile方法时，内容不能包含”: “(冒号+空格)，这个与ansible底层的分隔符冲突；</td>
<td>让用户在内容中不要包含”: “</td>
</tr>
<tr>
<td>https 相关</td>
<td>SSL validation is not available in your version of python. You can use validate_certs=no, however this is unsafe and not recommended. You can also install python-ssl from EPEL</td>
</tr>
<tr>
<td>You need a C++ compiler for C++ support</td>
<td>yum install -y gcc gcc-c++</td>
</tr>
<tr>
<td>１：udp权限问题，有时候会出现权限认证失败；２：udp如何执行本地命令；　３：udp线上有什么方便的安装方法</td>
<td>问题1:方法一 去掉sudo试试（报访问文件 /opt/aliUDP/logs/udp.log 失败，备份重新建一个udp.log 文件给于 777 权限）; 方法二 指定 –private-key=PRIVATE_KEY_FILE （先试试直接ssh登录某台目标机器行不行）  问题2：udp支持直接运行目标机器上的命令，用法：udp server  -i ~/ali/udp-roles/roles/udp-install/udp-hosts.ini  -m shell -a “ uptime ; df -lh “ -u admin</td>
</tr>
<tr>
<td>同一个ip部署不同的工程时，定义的变量会冲突；例如ip1同时部署mysql和diamond，都定义project_name；这样上面的会生效，下面定义的会被冲掉</td>
<td>Wiki：<a href="http://gitlab.alibaba-inc.com/middleware-udp/udp-doc/wikis/Different_Hosts_With_Different_Variables" target="_blank" rel="external">http://gitlab.alibaba-inc.com/middleware-udp/udp-doc/wikis/Different_Hosts_With_Different_Variables</a>  将变量分别定义在 ./roles/mysql/defaults/main.yml 和 ./roles/diamond/defaults/main.yml中 或者使用不同的变量名</td>
</tr>
<tr>
<td>执行udp-play-book 时会报找不到key的问题</td>
<td>在udp机器上执行 ssh-keygen 来生成key，解决</td>
</tr>
<tr>
<td>ssh 的时候需要手工 yes/no</td>
<td>增加参数 -o StrictHostKeyChecking no 就不需要输入了</td>
</tr>
<tr>
<td>防火墙问题，本地可以访问，远程不能</td>
<td>通过抓包/telnet等方式来确认这个问题， 通过iptables stop 来临时关闭防火墙； 修改iptables 的配置永久关闭或者增加所有其它节点到白名单中</td>
</tr>
<tr>
<td></td>
<td>重要！ hostname -i 一定要是本机在局域网内的真实ip地址（不是127.0.0.1 ）。  要绑定etc/hosts 下面 把自己的hostname绑定到对应的真实ip上。</td>
</tr>
<tr>
<td>在UDP PlayBook中如何定义不同的机器、不同的Role使用不同的变量</td>
<td><a href="http://gitlab.alibaba-inc.com/middleware-udp/udp-doc/wikis/Different_Hosts_With_Different_Variables" target="_blank" rel="external">http://gitlab.alibaba-inc.com/middleware-udp/udp-doc/wikis/Different_Hosts_With_Different_Variables</a></td>
</tr>
<tr>
<td>Dauth部署问题总结</td>
<td><a href="http://gitlab.alibaba-inc.com/middleware-udp/udp-doc/wikis/Dauth-UDP-deployment-issues" target="_blank" rel="external">http://gitlab.alibaba-inc.com/middleware-udp/udp-doc/wikis/Dauth-UDP-deployment-issues</a></td>
</tr>
<tr>
<td>Device or resource busy</td>
<td>一般出现在Docker中修改/etc/hosts会有这个问题，ansible会rm它，实际它是-v进去的，通过脚本补丁绕过去</td>
</tr>
</tbody>
</table>
<p>ansible 中 scp scp: ambiguous target 错误还是因为ssh 增加了 -t 参数, scp不支持 -t 参数</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="weibo @plantegg" />
          <p class="site-author-name" itemprop="name">weibo @plantegg</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">142</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">235</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">weibo @plantegg</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv_footer"></span>次
</span>
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv_footer"></span>人次
</span>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
